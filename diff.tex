\documentclass[11pt]{book}
%DIF LATEXDIFF DIFFERENCE FILE
%DIF DEL Old Scribe Notes/collection.tex   Fri Oct  4 21:57:26 2024
%DIF ADD collection-F24.tex                Fri Oct  4 21:57:38 2024
\usepackage{url,amsmath,setspace,amssymb,fullpage,color,tikz}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage[margin=1in]{geometry}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{graphicx}
\usepackage{frame,comment}
\usepackage{mathrsfs}
\usepackage{xspace, extarrows}
%DIF 13c13-14
%DIF < 
%DIF -------
\usepackage{xcolor} %DIF > 
\usepackage{enumitem} %DIF > 
%DIF -------
\floatstyle{boxed}
\restylefloat{figure}
%DIF 16a17-19
 %DIF > 
\usepackage[n,advantage,operators,sets,adversary,landau,probability,notions,logic,ff,mm,primitives,events,complexity,oracles,asymptotics,keys]{cryptocode}  %DIF > 
 %DIF > 
%DIF -------
\usepackage[most]{tcolorbox}
\newcommand{\heading}[5]{
   \renewcommand{\thepage}{#1-\arabic{page}}
   \noindent
   \begin{center}
   \framebox[\textwidth]{
     \begin{minipage}{0.9\textwidth} \onehalfspacing
       {\bf CS 276 -- Cryptography} \hfill #2

       {\centering \Large #5

       }\medskip

       {\it #3 \hfill #4}
     \end{minipage}
   }
   \end{center}
}

\newcommand{\scribe}[4]{\heading{#1}{#2}{Instructor:
Sanjam Garg}{GSI: #4}{Lecture #1: #3}}

%\setlength{\parindent}{0in}

\newcommand{\proof}{\noindent{\bf Proof. }} %% To begin a proof write \proof
\newcommand{\qed}{\mbox{}\hspace*{\fill}\nolinebreak\mbox{$\rule{0.6em}{0.6em}$}} %%to end your proof write $\qed$.
%DIF 42c46
%DIF < \newcommand{\ma}{{\mathcal A}}
%DIF -------
%\newcommand{\ma}{{\mathcal A}} %DIF > 
%DIF -------
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{remark}{Remark}[chapter]
\newtheorem{claim}{Claim}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{corollary}{Corollary}[chapter]
\newtheorem{construction}{Construction}[chapter]
\newtheorem{definition}{Definition}[chapter]
\newtheorem{proposition}{Proposition}[chapter]
\newtheorem{exercise}{Exercise}[chapter]
%DIF 52d56
%DIF < \bibliographystyle{plain}
%DIF -------

%DIF 54a57-59
\newenvironment{marginfigure}[1][] %DIF > 
{\begin{figure}} %DIF > 
{\end{figure}} %DIF > 
%DIF -------

%DIF 55a61
\bibliographystyle{alpha} %DIF > 
%DIF -------

%DIF 56c63-69
%DIF < %\newtcolorbox[auto counter,list inside=defs,number within=section]{definition}[2][]{title={Definition~\thetcbcounter},colback={white!30!yellow},colbacktitle={gray},coltitle=black,#1}
%DIF -------
%\newcommand{\binset}[1]{\{ 0, 1 \}^{#1}} %DIF > 
%\newcommand{\binfunc}[2]{\binset{#1} \rightarrow \binset{#2}} %DIF > 
\newcommand{\marginnote}[2][1]{#2} %DIF > 
\newcommand{\ma}{\mathcal{A}} %DIF > 
\newcommand{\cA}{\mathcal{A}} %DIF > 
\newcommand{\mb}{\mathcal{B}} %DIF > 
\newcommand{\cB}{\mathcal{B}} %DIF > 
%DIF -------

%DIF 58-59c71-72
%DIF < \newcommand{\binset}[1]{\{ 0, 1 \}^{#1}}
%DIF < \newcommand{\binfunc}[2]{\binset{#1} \rightarrow \binset{#2}}
%DIF -------
\newcommand{\getsr}{\xleftarrow{\$}} %DIF > 
\newcommand{\bit}{\{0,1\}} %DIF > 
%DIF -------

%DIF 61c74-81
%DIF < \newcommand{\concat}[0]{\; || \;}
%DIF -------
\newcommand{\Gen}{\mathsf{Gen}} %DIF > 
\newcommand{\gen}{\mathsf{Gen}} %DIF > 
\newcommand{\Enc}{\mathsf{Enc}} %DIF > 
% \newcommand{\enc}{\mathsf{Enc}} %DIF > 
\newcommand{\Dec}{\mathsf{Dec}} %DIF > 
% \newcommand{\dec}{\mathsf{Dec}} %DIF > 
% \newcommand{\pk}{\mathsf{pk}} %DIF > 
% \newcommand{\sk}{\mathsf{sk}} %DIF > 
%DIF -------

%DIF 63a83-107
% \newcommand{\concat}[0]{\; || \;} %DIF > 
 %DIF > 
% \newcommand{\bin}{\{0,1\}} %DIF > 
% \newcommand{\adv}{\mathcal{A}} %DIF > 
% \newcommand{\advb}{\mathcal{B}} %DIF > 
% \newcommand{\advc}{\mathcal{C}} %DIF > 
% \newcommand{\fake}{\mathsf{FAKE}} %DIF > 
 %DIF > 
\newcommand{\Sign}{\mathsf{Sign}} %DIF > 
\newcommand{\Verify}{\mathsf{Verify}} %DIF > 
%\newcommand{\negl}{\mathsf{negl}} %DIF > 
\newcommand{\abort}{\mathsf{abort}} %DIF > 
\newcommand{\Sampler}{\mathsf{Sampler}} %DIF > 
\newcommand{\Eval}{\mathsf{Eval}} %DIF > 
\renewcommand{\tag}{\mathsf{tag}} %DIF > 
\newcommand{\PRF}{\mathsf{PRF}} %DIF > 
 %DIF > 
 %DIF > 
\newcommand{\mright}[3]{ %DIF > 
    $#1$ & \quad$\xrightarrow{\parbox{3cm}{\centering$#2$}}$\quad & $#3$ \\ %DIF > 
} %DIF > 
\newcommand{\mleft}[3]{ %DIF > 
    $#1$ & \quad$\xleftarrow{\parbox{3cm}{\centering$#2$}}$\quad & $#3$ \\ %DIF > 
} %DIF > 
 %DIF > 
%DIF -------
\newcommand{\tnotes}[1]{{\color{red} Teaching Notes: #1}}

\newcommand{\sanjam}[1]{{\color{red} Sanjam: #1}}

%DIF 67c112
%DIF < \newcommand{\peihan}[1]{{\color{blue} Peihan: #1}}
%DIF -------
\newcommand{\bhaskar}[1]{{\color{ForestGreen} Bhaskar: #1}} %DIF > 
%DIF -------
\renewcommand{\sanjam}[1]{}

%\DeclarePairedDelimiter{\Prfences}{[}{]}

\title{\DIFdelbegin \DIFdel{CS276: Graduate Cryptography}%DIFDELCMD < \thanks{Based on scribe notes by students from taking CS276 in fall 2014. Also, thanks to Peihan Miao and Akshayaram Srinivasan for helping improve these notes.}%%%
\DIFdelend \DIFaddbegin \DIFadd{CS 276}\DIFaddend \\
\DIFdelbegin \DIFdel{\textbf{This draft is continually being updated.}}\DIFdelend \DIFaddbegin \DIFadd{Lecture Notes On Graduate Cryptography}\\
\DIFadd{\textcolor{red}{This draft is continually being updated.}}\DIFaddend }
\author{Sanjam Garg \DIFaddbegin \DIFadd{et al.}\thanks{These lecture notes are based on scribe notes taken by students in CS 276 over the years. Also, thanks to Peihan Miao, Akshayaram Srinivasan, and Bhaskar Roberts for helping to improve these notes.}\DIFaddend \\ University of California, Berkeley}
\date{\DIFaddbegin \DIFadd{Fall 2024}\DIFaddend } %DIF > 
%DIF PREAMBLE EXTENSION ADDED BY LATEXDIFF
%DIF UNDERLINE PREAMBLE %DIF PREAMBLE
\RequirePackage[normalem]{ulem} %DIF PREAMBLE
\RequirePackage{color}\definecolor{RED}{rgb}{1,0,0}\definecolor{BLUE}{rgb}{0,0,1} %DIF PREAMBLE
\providecommand{\DIFadd}[1]{{\protect\color{blue}\uwave{#1}}} %DIF PREAMBLE
\providecommand{\DIFdel}[1]{{\protect\color{red}\sout{#1}}}                      %DIF PREAMBLE
%DIF SAFE PREAMBLE %DIF PREAMBLE
\providecommand{\DIFaddbegin}{} %DIF PREAMBLE
\providecommand{\DIFaddend}{} %DIF PREAMBLE
\providecommand{\DIFdelbegin}{} %DIF PREAMBLE
\providecommand{\DIFdelend}{} %DIF PREAMBLE
\providecommand{\DIFmodbegin}{} %DIF PREAMBLE
\providecommand{\DIFmodend}{} %DIF PREAMBLE
%DIF FLOATSAFE PREAMBLE %DIF PREAMBLE
\providecommand{\DIFaddFL}[1]{\DIFadd{#1}} %DIF PREAMBLE
\providecommand{\DIFdelFL}[1]{\DIFdel{#1}} %DIF PREAMBLE
\providecommand{\DIFaddbeginFL}{} %DIF PREAMBLE
\providecommand{\DIFaddendFL}{} %DIF PREAMBLE
\providecommand{\DIFdelbeginFL}{} %DIF PREAMBLE
\providecommand{\DIFdelendFL}{} %DIF PREAMBLE
\newcommand{\DIFscaledelfig}{0.5}
%DIF HIGHLIGHTGRAPHICS PREAMBLE %DIF PREAMBLE
\RequirePackage{settobox} %DIF PREAMBLE
\RequirePackage{letltxmacro} %DIF PREAMBLE
\newsavebox{\DIFdelgraphicsbox} %DIF PREAMBLE
\newlength{\DIFdelgraphicswidth} %DIF PREAMBLE
\newlength{\DIFdelgraphicsheight} %DIF PREAMBLE
% store original definition of \includegraphics %DIF PREAMBLE
\LetLtxMacro{\DIFOincludegraphics}{\includegraphics} %DIF PREAMBLE
\newcommand{\DIFaddincludegraphics}[2][]{{\color{blue}\fbox{\DIFOincludegraphics[#1]{#2}}}} %DIF PREAMBLE
\newcommand{\DIFdelincludegraphics}[2][]{% %DIF PREAMBLE
\sbox{\DIFdelgraphicsbox}{\DIFOincludegraphics[#1]{#2}}% %DIF PREAMBLE
\settoboxwidth{\DIFdelgraphicswidth}{\DIFdelgraphicsbox} %DIF PREAMBLE
\settoboxtotalheight{\DIFdelgraphicsheight}{\DIFdelgraphicsbox} %DIF PREAMBLE
\scalebox{\DIFscaledelfig}{% %DIF PREAMBLE
\parbox[b]{\DIFdelgraphicswidth}{\usebox{\DIFdelgraphicsbox}\\[-\baselineskip] \rule{\DIFdelgraphicswidth}{0em}}\llap{\resizebox{\DIFdelgraphicswidth}{\DIFdelgraphicsheight}{% %DIF PREAMBLE
\setlength{\unitlength}{\DIFdelgraphicswidth}% %DIF PREAMBLE
\begin{picture}(1,1)% %DIF PREAMBLE
\thicklines\linethickness{2pt} %DIF PREAMBLE
{\color[rgb]{1,0,0}\put(0,0){\framebox(1,1){}}}% %DIF PREAMBLE
{\color[rgb]{1,0,0}\put(0,0){\line( 1,1){1}}}% %DIF PREAMBLE
{\color[rgb]{1,0,0}\put(0,1){\line(1,-1){1}}}% %DIF PREAMBLE
\end{picture}% %DIF PREAMBLE
}\hspace*{3pt}}} %DIF PREAMBLE
} %DIF PREAMBLE
\LetLtxMacro{\DIFOaddbegin}{\DIFaddbegin} %DIF PREAMBLE
\LetLtxMacro{\DIFOaddend}{\DIFaddend} %DIF PREAMBLE
\LetLtxMacro{\DIFOdelbegin}{\DIFdelbegin} %DIF PREAMBLE
\LetLtxMacro{\DIFOdelend}{\DIFdelend} %DIF PREAMBLE
\DeclareRobustCommand{\DIFaddbegin}{\DIFOaddbegin \let\includegraphics\DIFaddincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFaddend}{\DIFOaddend \let\includegraphics\DIFOincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFdelbegin}{\DIFOdelbegin \let\includegraphics\DIFdelincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFdelend}{\DIFOaddend \let\includegraphics\DIFOincludegraphics} %DIF PREAMBLE
\LetLtxMacro{\DIFOaddbeginFL}{\DIFaddbeginFL} %DIF PREAMBLE
\LetLtxMacro{\DIFOaddendFL}{\DIFaddendFL} %DIF PREAMBLE
\LetLtxMacro{\DIFOdelbeginFL}{\DIFdelbeginFL} %DIF PREAMBLE
\LetLtxMacro{\DIFOdelendFL}{\DIFdelendFL} %DIF PREAMBLE
\DeclareRobustCommand{\DIFaddbeginFL}{\DIFOaddbeginFL \let\includegraphics\DIFaddincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFaddendFL}{\DIFOaddendFL \let\includegraphics\DIFOincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFdelbeginFL}{\DIFOdelbeginFL \let\includegraphics\DIFdelincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFdelendFL}{\DIFOaddendFL \let\includegraphics\DIFOincludegraphics} %DIF PREAMBLE
%DIF COLORLISTINGS PREAMBLE %DIF PREAMBLE
\RequirePackage{listings} %DIF PREAMBLE
\RequirePackage{color} %DIF PREAMBLE
\lstdefinelanguage{DIFcode}{ %DIF PREAMBLE
%DIF DIFCODE_UNDERLINE %DIF PREAMBLE
  moredelim=[il][\color{red}\sout]{\%DIF\ <\ }, %DIF PREAMBLE
  moredelim=[il][\color{blue}\uwave]{\%DIF\ >\ } %DIF PREAMBLE
} %DIF PREAMBLE
\lstdefinestyle{DIFverbatimstyle}{ %DIF PREAMBLE
	language=DIFcode, %DIF PREAMBLE
	basicstyle=\ttfamily, %DIF PREAMBLE
	columns=fullflexible, %DIF PREAMBLE
	keepspaces=true %DIF PREAMBLE
} %DIF PREAMBLE
\lstnewenvironment{DIFverbatim}{\lstset{style=DIFverbatimstyle}}{} %DIF PREAMBLE
\lstnewenvironment{DIFverbatim*}{\lstset{style=DIFverbatimstyle,showspaces=true}}{} %DIF PREAMBLE
%DIF END PREAMBLE EXTENSION ADDED BY LATEXDIFF

\begin{document}
\maketitle
\DIFdelbegin %DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdelend \tableofcontents

\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/lec02.tex}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \chapter{\DIFadd{Mathematical Background}}
\label{sec:mb}
\DIFaddend 

\DIFdelbegin %DIFDELCMD < \newcommand{\gen}{\mathsf{Gen}}
%DIFDELCMD < \newcommand{\enc}{\mathsf{Enc}}
%DIFDELCMD < \newcommand{\dec}{\mathsf{Dec}}
%DIFDELCMD < \newcommand{\pk}{\mathsf{pk}}
%DIFDELCMD < \newcommand{\sk}{\mathsf{sk}}
%DIFDELCMD < \newcommand{\fake}{\mathsf{FAKE}}
%DIFDELCMD < \newcommand{\mright}[3]{
%DIFDELCMD <     $#1$ & \quad$\xrightarrow{\parbox{3cm}{\centering$#2$}}$\quad & $#3$ \\
%DIFDELCMD < }
%DIFDELCMD < \newcommand{\mleft}[3]{
%DIFDELCMD <     $#1$ & \quad$\xleftarrow{\parbox{3cm}{\centering$#2$}}$\quad & $#3$ \\
%DIFDELCMD < }
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \DIFadd{In modern cryptography, (1) we typically assume that our attackers cannot run in unreasonably large amounts of time, and (2) we allow security to be broken with a }\emph{\DIFadd{very small}}\DIFadd{, but non-zero, probability.
}\DIFaddend 

\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/lec05.tex}
%DIFDELCMD < \input{Old Scribe Notes/lec06.tex}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \DIFadd{Without these assumptions, we must work in the realm of information-theoretic cryptography, which is often unachievable or impractical for many applications. For example, the one-time pad
}\footnote{\DIFadd{For a message $m \in \{0,1\}^n$ and a random key $k \in \{0,1\}^n$, the encryption of $m$ is $c = m \oplus k$. The decryption is $m = c \oplus k$.}}
\DIFadd{-- an information-theoretically secure cipher -- is not very useful because it requires very large keys.
}\DIFaddend 

\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/assumptions}  
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \DIFadd{In this chapter, we define items (1) and (2) more formally. We require our adversaries to run in polynomial time, which captures the idea that their runtime is not unreasonably large (sections~\ref{ssec:ppt}). We also allow security to be broken with negligible -- very small -- probability (section ~\ref{ssec:nnf}). 
}\DIFaddend 


%DIF < Signatures
\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/lec13}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \section{\DIFadd{Probabilistic Polynomial Time}}
\label{ssec:ppt}
\DIFadd{A probabilistic Turing Machine is a generic computer that is allowed to make random choices during its execution. A probabilistic }\textit{\DIFadd{polynomial time}} \DIFadd{Turing Machine is one which halts in time polynomial in its input length. More formally:
}\DIFaddend 

%DIF < PKE
\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/lec09}
%DIFDELCMD < \input{Old Scribe Notes/lec12}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \begin{definition}[Probabilistic Polynomial Time]
\DIFadd{A probabilistic Turing Machine $M$ is said to be PPT (a Probabilistic Polynomial Time Turing Machine) if $\exists c \in \mathbb{Z}^+$ such that $\forall x \in\{0,1\}^*$, $M(x)$ halts in $|x|^c$ steps.
}\end{definition}
\DIFaddend 

%DIF < IBE
\DIFaddbegin \DIFadd{A }{\em \DIFadd{non-uniform}} \DIFadd{PPT Turing Machine is a collection of machines one for each input length, as opposed to a single machine that must work for all input lengths.
}

\begin{definition}[Non-uniform PPT]
\DIFadd{A non-uniform PPT machine is a sequence of Turing Machines $\{ M_1, M_2, \cdots \}$ such that $\exists c \in \mathbb{Z}^+$ such that $\forall x \in\{0,1\}^*$, $M_{|x|}(x)$ halts in $|x|^c$ steps.
}\end{definition}



\section{\DIFadd{Noticeable and Negligible Functions}}
\label{ssec:nnf}
\DIFadd{Noticeable and negligible functions are used to characterize the ``largeness'' or ``smallness'' of a function describing the probability of some event.  Intuitively, a noticeable function is required to be larger than some inverse-polynomially function in the input parameter. On the other hand, a negligible function must be smaller than any inverse-polynomial function of the input parameter. More formally:
}


\begin{definition}[Noticeable Function]
\DIFadd{A function $\mu(\cdot): \mathbb{Z}^+ \rightarrow [0,1]$ is noticeable iff $\exists c \in \mathbb{Z}^+, n_0 \in \mathbb{Z}^+$ such that $\forall n \geq n_0 , \; \mu(n) > n^{-c}$.
}\end{definition}

\paragraph{\DIFadd{Example.}} \DIFadd{Observe that $\mu(n) = n^{-3}$ is a noticeable function.  (Notice that the above definition is satisfied for $c = 4$ and $n_0 = 1$.)
}

\begin{definition}[Negligible Function]
\DIFadd{A function $\mu(\cdot): \mathbb{Z}^+ \rightarrow [0,1]$ is negligible iff $\forall c \in \mathbb{Z}^+ \; \exists n_0 \in \mathbb{Z}^+$ such that $\forall n \geq n_0 , \; \mu(n) < n^{-c}$.
}\end{definition}

\paragraph{\DIFadd{Example.}} \DIFadd{$\mu(n) = 2^{-n}$ is an example of a negligible function. This can be observed as follows.
Consider an arbitrary $c \in \mathbb{Z}^+$ and set $n_0 = c^2$. Now, observe that for all $n \geq n_0$, we have that $\frac{n}{\log_2 n} \geq \frac{n_0}{\log_2 n_0} > \frac{n_0}{\sqrt{n_0}} = \sqrt{n_0} = c$. This allows us to conclude that }$$\DIFadd{\mu(n) = 2^{-n} = n^{-\frac{n}{\log_2 n}} < n^{-c}.}$$

\DIFadd{Thus, we have proved that for any $c \in \mathbb{Z}^+$, there exists $n_0 \in \mathbb{Z}^+$ such that for any $n \geq n_0$, $\mu(n) < n^{-c}$.
}

\paragraph{\DIFadd{Gap between Noticeable and Negligible Functions.}}
\DIFadd{At first thought it might seem that a function that is }{\DIFadd{not}} \DIFadd{negligible (or, a non-negligible function) must be a noticeable. This is not true!\mbox{%DIFAUXCMD
\cite{JC:Bellare02} }\hskip0pt%DIFAUXCMD
Negating the definition of a negligible function, we obtain that a non-negligible function $\mu(\cdot)$ is such that $\exists c \in \mathbb{Z}^+$ such that $\forall n_0 \in \mathbb{Z}^+$, $\exists n \geq n_0$ such that $\mu(n) > n^{-c}$.
Note that this requirement is satisfied as long as $\mu(n) > n^{-c}$ for infinitely many choices of $n \in \mathbb{Z}^+$. However, a noticeable function requires this condition to be true for every $n \geq n_0$.
}

\DIFadd{Below we give example of a function $\mu(\cdot)$ that is neither negligible nor noticeable.
}$$\DIFadd{\mu(n) = \Big\{
\begin{array}{ll}
  2^{-n} & : x \mod 2 = 0\\
  n^{-3} & : x \mod 2 \neq 0
\end{array}
}$$
\DIFadd{This function is obtained by interleaving negligible and  noticeable functions. It cannot be negligible (resp., noticeable) because it is greater (resp., less) than an inverse-polynomially function for infinitely many input choices.
}

\paragraph{\DIFadd{Properties of Negligible Functions.}} \DIFadd{Sum and product of two negligible functions is still a negligible function. We argue this for the sum function below and defer the problem for products to Exercise~\ref{ex:product}. These properties together imply that any polynomial function of a negligible function is still negligible.
}

\begin{exercise}
\DIFadd{If $\mu(n)$ and $\nu(n)$ are negligible functions from domain $\mathbb{Z}^+$ to range $[0,1]$ then prove that the following functions are also negligible:
}\begin{enumerate}
    \item \DIFadd{$\psi_1(n) = \frac{1}{2} \cdot \left(\mu(n) + \nu(n)\right)$
    }\item \DIFadd{$\psi_2(n) = \min\{\mu(n) + \nu(n), 1\}$
    }\item \DIFadd{$\psi_3(n) = \mu(n)\cdot \nu(n)$
    }\item \DIFadd{$\psi_4(n) = \mathsf{poly}(\mu(n))$, where $\mathsf{poly}(\cdot)$ is an unspecified polynomial function. (Assume that the output is also clamped to $[0,1]$ to satisfy the definition)
}\end{enumerate}\DIFadd{function.
}\end{exercise}
\proof 
\DIFadd{$ $
}\begin{enumerate}
    \item \DIFadd{We need to show that for any $c \in \mathbb{Z}^+$, we can find $n_0$ such that $\forall n \geq n_0$, $\psi_1(n) \leq n^{-c}$. Our argument proceeds as follows. Given the fact that $\mu$ and $\nu$ are negligible we can conclude that there exist $n_1$ and $n_2$ such that $\forall n \geq n_1$, $\mu(n) < n^{-c}$ and $\forall n \geq n_2$, $g(n) < n^{-c}$. Combining the above two facts and setting $n_0 = \max(n_1, n_2)$ we have that for every $n \geq n_0$,
    }\begin{align*}
        \DIFadd{\psi_1(n) }&\DIFadd{= \frac{1}{2} \cdot (\mu(n) + \nu(n)) < \frac{1}{2} \cdot (n^{-c} + n^{-c}) = n^{-c}
    }\end{align*}
    \DIFadd{Thus, $\psi_1(n) \leq n^{-c}$ and hence is negligible.
}

    \item \DIFadd{We need to show that for any $c \in \mathbb{Z}^+$, we can find $n_0$ such that $\forall n \geq n_0$, $\psi_2(n) \leq n^{-c}$. Given the fact that $\mu$ and $\nu$ are negligible, there exist $n_1$ and $n_2$ such that $\forall n \geq n_1$, $\mu(n) \leq n^{-c-1}$ and $\forall n \geq n_2$, $g(n) \leq n^{-c-1}$. Setting $n_0 = \max(n_1, n_2, 3)$ we have that for every $n \geq n_0$,
    }\begin{align*}
        \DIFadd{\psi_2(n) }&\DIFadd{= \min\{\mu(n) + \nu(n), 1\} < n^{-c-1} + n^{-c-1} < n^{-c}
    }\end{align*}
\end{enumerate}
\qed

%DIF > \begin{corollary}
%DIF > If $f(n)$ is non-negligible and $g(n)$ is negligible, then $h(n) = f(n) - g(n)$ is non-negligible.
%DIF > \end{corollary}
\DIFaddend %
%DIF > \proof If $h(n)$ was negligible, then $f(n) = g(n) + h(n)$ would be the sum of two negligible functions, but would be non-negligible, which is a contradiction.  \qed

\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/lec07}
%DIFDELCMD < \input{Old Scribe Notes/lec08}
%DIFDELCMD < %%%
%DIF < NIZK
%DIF < \input{Old Scribe Notes/lec10.tex}
%DIF < \input{Old Scribe Notes/lec11.tex}
\DIFdelend \DIFaddbegin \section{\DIFadd{Computationally  Hard Problems}}\label{sec:assumptions}
%DIF > So far, much of our investigation relied on the existence of one-way-functions or in certain cases on the existence of one-one one-way functions. However, just the mere existence of an object is not enough for real-world implementations. 
\DIFadd{We will next provide certain number theoretical problems that are conjectured to be computationally intractable. We will use the conjectured hardness of these problems in subsequent chapters to o provide concrete instantiations.
}\DIFaddend 

\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/lec14}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \subsection{\DIFadd{The Discrete-Log Family of Problem}}
\DIFadd{Consider a group $\mathbb{G}$ of prime order. For example, consider the group $\mathbb{Z}_p^*$ where $p$ is a large prime. Let $g$ be a generator of this group $\mathbb{G}$. In this group, given $g^x$ for a random $x \in \{1,\ldots p-1\}$ consider the problem of finding $x$. This problem, referred to as the discrete-log problem, is believed to be computationally hard.
}\DIFaddend 

%DIF < Secure Computation
\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/lec15}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \DIFadd{The asymptotic definition of the discrete-log problem needs to consider an infinite family of groups or what we will a group ensemble. 
}\DIFaddend 

\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/sec_com}
%DIFDELCMD < \input{Old Scribe Notes/lec16}
%DIFDELCMD < %%%
%DIF < \input{Old Scribe Notes/oram.tex}
\DIFdelend \DIFaddbegin \paragraph{\DIFadd{Group Ensemble.}} \DIFadd{A group ensemble is a set of finite cyclic groups $\mathcal{G} =\{ \mathbb{G}_n\}_{n \in \mathbb{N}}$. For the group $G_n$, we assume that given two group elements in $G_n$, their sum can be computed in polynomial in $n$ time. Additionally, we assume that given $n$ the generator $g$ of $\mathbb{G}_n$ can be computed in polynomial time. 
}\DIFaddend 

\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/lec18}
%DIFDELCMD < \input{Old Scribe Notes/lec19}
%DIFDELCMD < \input{Old Scribe Notes/lec20}
%DIFDELCMD < \input{Old Scribe Notes/lec22}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \begin{definition}[Discrete-Log Assumption]\label{def:dl}
\DIFadd{We say that the discrete-log assumption holds for the group ensemble $\mathcal{G} =\{ \mathbb{G}_n\}_{n \in \mathbb{N}}$, if for every non-uniform PPT algorithm $\mathcal{A}$ we have that
}\[\DIFadd{\mu_\mathcal{A}(n) := \Pr_{x \leftarrow |G_n|}[\mathcal{A}(g,g^x) = x]}\]
\DIFadd{is a negligible function.
}\end{definition}
\DIFaddend 

\DIFaddbegin \paragraph{\DIFadd{The Diffie-Hellman Problems.}} \DIFadd{In addition to the discrete-log assumption, we also define the Computational Diffie-Hellman Assumption and the Decisional Diffie-Hellman Assumption. 
}

\begin{definition}[Computational Diffie-Hellman (CDH) Assumption]\label{def:cdh}
\DIFadd{We say that the Computational Diffie-Hellman Assumption holds for the group ensemble $\mathcal{G} =\{ \mathbb{G}_n\}_{n \in \mathbb{N}}$, if for every non-uniform PPT algorithm $\mathcal{A}$ we have that
}\[\DIFadd{\mu_\mathcal{A}(n) := \Pr_{x,y \leftarrow |G_n|}[\mathcal{A}(g,g^x,g^y) = g^{xy}]}\]
\DIFadd{is a negligible function.
}\end{definition}

\begin{definition}[Decisional Diffie-Hellman (DDH) Assumption]\label{def:ddh}
\DIFadd{We say that the Computational Diffie-Hellman Assumption holds for the group ensemble $\mathcal{G} =\{ \mathbb{G}_n\}_{n \in \mathbb{N}}$, if for every non-uniform PPT algorithm $\mathcal{A}$ we have that
}\[\DIFadd{\mu_\mathcal{A}(n) = \mid\Pr_{x,y \leftarrow |G_n|}[\mathcal{A}(g,g^x,g^y,g^{xy}) = 1] - \Pr_{x,y,z \leftarrow |G_n|}[\mathcal{A}(g,g^x,g^y,g^{z}) = 1]\mid}\]
\DIFadd{is a negligible function.
}\end{definition}

\DIFadd{It is not hard to observe that the discrete-log assumption is the weakest of the three assumptions above. In fact, it is not difficult to show that the Discrete-Log Assumption for $\mathcal{G}$ implies the CDH and the DDH Assumptions for $\mathcal{G}$.  Additionally, we leave it as an exercise to show that the CDH Assumption for $\mathcal{G}$ implies the  DDH Assumptions for $\mathcal{G}$.
}

\paragraph{\DIFadd{Examples of Groups where these assumptions hold.}} \DIFadd{Now we provide some examples of group where these assumptions hold. 
}\begin{enumerate}
    \item \DIFadd{Consider the group $\mathbb{Z}_p^*$ for a prime $p$.}\footnote{\DIFadd{Since the number of primes is infinite we can define an infinite family of such groups. For the sake of simplicity, here we only consider a single group.}} \DIFadd{For this group the CDH Assumption is conjectured to be true. However, using the Legendre symbol,}\footnote{\DIFadd{Let $p$ be an odd prime number. An integer $a$ is said to be a }\emph{\DIFadd{quadratic residue}} \DIFadd{modulo $p$ if it is congruent to a perfect square modulo $p$ and  is said to be a }\emph{\DIFadd{quadratic non-residue}} \DIFadd{modulo $p$ otherwise. The }\emph{\DIFadd{Legendre symbol}} \DIFadd{is a function of $a$ and $p$ defined as
    }\begin{equation*}
        \DIFadd{\left(\frac{a}{p}\right) = \begin{cases}
    1 &\text{if $a$ is quadration residue mod $p $ and $a \not\equiv 0 \mod p$}\\
    -1 &\text{if $a$ is quadration non-residue mod $p $}\\
    0 &\text{if $a \equiv 0 \mod p $}
    \end{cases}
    }\end{equation*}

\DIFadd{Legendre symbol can be efficiently computed as $\left(\frac{a}{p}\right) = a^{\frac{p-1}{2}}\mod p$.}} 
\DIFadd{the DDH Assumption in this group can be shown to be false. Can you show how?}\footnote{\DIFadd{This is because given $g^x, g^y$ one can easily compute deduce the Legendre symbol of $g^{xy}$.  Observe that if $\left(\frac{g}{p}\right) = -1$ then we have that $\left(\frac{g^{xy}}{p}\right) = 1$ if and only if $ \left(\frac{g^x}{p}\right) =1 $ or $\left(\frac{g^y}{p}\right) = 1$. Using this fact, we can construct an adversary that breaks the DDH problem with a non-negligible (in fact, noticeable) probability.}}
\item \DIFadd{Let $p = 2q+1$ where both $p$ and $q$ are prime.}\footnote{\DIFadd{By Dirichet's Theorem on primes in arithmetic progression, we have that there are infinite choices of primes $(p,q)$ for which $p = 2q+1$. This allows us to generalize this group to a group ensemble.}} \DIFadd{Next, let $\mathbb{Q}$ be the order-$q$ subgroup of quadratic residues in $\mathbb{Z}^*_p$. For this group, the DDH assumption is believed to hold. 
}\item \DIFadd{Let $N = pq$ where $p,q, \frac{p-1}{2}$ and $\frac{q-1}{2}$ are primes. Let $\mathbb{QR}_N$ be the cyclic subgroup of qudratic resides of order $\phi(N) = (p-1)(q-1)$. For this group $\mathbb{QR}_N$, the DDH assumption is also believed to hold.
%DIF > \item Pairings:
}\end{enumerate}

\paragraph{\DIFadd{Is DDH strictly stronger than Discrete-Log?}} \DIFadd{In the example cases above, where DDH is known believed to be hard, the
best known algorithms for DDH are no better than the best known algorithms for the discrete-log problem. Whether the DDH assumption is strictly stronger than the discrete-log assumption is an open problem. 
}



\subsection{\DIFadd{CDH in $\mathbb{QR}_N$ implies Factoring}}

\DIFadd{In this section, we will show that the CDH assumption in $\mathbb{QR}_N$ implies the factoring assumption. 
}\begin{lemma}
\DIFadd{Given an algorithm $\mathcal{A}$ that breaks the CDH assumption in $\mathbb{QR}_N$, we construct an non-uniform PPT adversary $\mathcal{B}$ that on input $N$ outputs its prime factors $p$ and $q$.
}\end{lemma}
\begin{proof}
\DIFadd{Given that $\mathcal{A}$ is an algorithm that solves the CDH problem in $\mathbb{QR}_N$ with a non-negligible probability, we construct an algorithm $\mathcal{B}$ that can factor $N$. Specifically, $\mathcal{B}$ on input $N$ proceeds as follows:
}\begin{enumerate}
\item \DIFadd{Sample $v \leftarrow \mathbb{QR}_N$ (such a $v$ can be obtained by sampling a random value in $\mathbb{Z}_N^*$ and squaring it) and compute $g := v^2 \mod N$.
}\item \DIFadd{Sample $x, y \leftarrow [N]$.}\footnote{\DIFadd{Note that sampling $x,y$ uniformly from $[N]$ is statistically close to sampling $x,y$ uniformly from $[\phi(N)]$.}}
\item \DIFadd{Let $ u := \mathcal{A}(g, g^{x}\cdot v, g^y\cdot v)$}\footnote{\DIFadd{Note that $g^x\cdot v$ where $x \leftarrow [N]$ is statistically close to $g^x$ where $x \leftarrow [N]$.}} \DIFadd{and compute $w := \frac{u}{g^{xy}\cdot v^{x+y}}$.
}\item \DIFadd{If $w^2 = v^2 \mod N$ and $u \neq \pm v$, then compute the factors of $N$ as $\mathsf{gcd}(N,u+v)$ and $N/\mathsf{gcd}(N,u+v)$. Otherwise, output $\bot$.
}\end{enumerate}
\DIFadd{Observe that if $\mathcal{A}$ solves the CDH problem then the returned values $u = g^{(x+ 2^{-1})(y + 2^{-1})} = v^{2xy + x+ y + 2^{-1}}$. Consequently, the computed value $w = v^{2^{-1}}$. Furthermore, with probability $\frac{1}{2}$ we have that $w \neq v$. In this case, $\mathcal{B}$ can factor $N$.
}\end{proof}
\newcommand{\binset}[1]{\{0,1\}^{#1}}
\newcommand{\binfunc}[2]{\binset{#1}\rightarrow\binset{#2}}
%DIF > \newcommand{\bin}{\{0,1\}}
%DIF > \newcommand{\adv}{\mathcal{A}}
\newcommand{\advb}{\mathcal{B}}
\newcommand{\advc}{\mathcal{C}}

\chapter{\DIFadd{One-Way Functions}}
\label{sec:owf}

\label{ssec:owf}
\DIFadd{Cryptographers often attempt to base cryptographic results on conjectured computational assumptions to leverage reduced adversarial capabilities. Furthermore, the security of these constructions is no better than the assumptions they are based on. 
}\begin{quote}
\emph{\DIFadd{Cryptographers seldom sleep well.}}\footnote{\DIFadd{Quote by Silvio Micali in personal communication with Joe Kilian.}}
\end{quote}
\DIFadd{Thus, basing cryptographic tasks on the }\emph{\DIFadd{minimal}} \DIFadd{necessary assumptions is a key tenet in cryptography. Towards this goal, rather can making assumptions about specific computational problem in number theory, cryptographers often consider }\emph{\DIFadd{abstract primitives}}\DIFadd{. The existence of these abstract primitives can then be based on one or more computational problems in number theory.
}

\DIFadd{The weakest abstract primitive cryptographers consider is one-way functions. Virtually, every cryptographic goal of interest is known to imply the existence of one-way functions. In other words, most cryptographic tasks would be impossible if the existence of one-way functions was ruled out. On the flip side, the realizing cryptographic tasks from just one-way functions would be ideal. 
}

\section{\DIFadd{Definition}}
\DIFadd{A one-way function $f: \{0,1\}^n \rightarrow \{0,1\}^m$ is a function that is easy to compute but hard to invert. This intuitive notion is trickier to formalize than it might appear on first thought.
}

\begin{definition}[One-Way Functions]
\DIFadd{A function $f : \binset{*} \rightarrow \binset{*}$ is said to be one-way function if:
}\begin{itemize}
\item[\DIFadd{-}] \textbf{\DIFadd{Easy to Compute:}} \DIFadd{$\exists$ a (deterministic) polynomial time machine $M$ such that $\forall x \in \binset{*}$ we have that }\[\DIFadd{M(x) = f(x)}\]

\item[\DIFadd{-}] \textbf{\DIFadd{Hard to Invert:}} \DIFadd{$\forall$ non-uniform PPT adversary $\mathcal{A}$ we have that
    }\begin{equation}\DIFadd{\label{eq:owf}
    \mu_{\mathcal{A},f}(n) = \Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{A}(1^n, f(x)) \in f^{-1}(f(x))]
     }\end{equation}
     \DIFadd{is a negligible function,  $x \overset{\$}{\leftarrow} \binset{n}$ denotes that $x$ is drawn uniformly at random from the set $\binset{n}$, $f^{-1}(f(x)) = \{x' \mid f(x) = f(x')\}$, and the probability is over the random choices of $x$ and the random coins of $\mathcal{A}$}\footnotemark\DIFadd{.
}\end{itemize}
\end{definition}

\begin{marginfigure}[-10cm]
\begin{tikzpicture}
    % ellipse
    \draw[black,fill=yellow!50] (0,0) ellipse (1cm and 2cm)
    node at (0,0) {$\{0,1\}^n$};
    \draw[black,fill=orange!50] (3,0) ellipse (1cm and 2cm) 
    node at (3,0) {$\{0,1\}^m$};
    % lines connecting ellipses
    \draw[green!40!black!100, thick, ->] (0.5,0.75) -- (2.5,0.75) node[midway, above] {Easy to Compute};
    \draw[red!40!black!100, thick, dashed, ->] (2.5,-0.75) -- (0.5,-0.75) node[midway, below] {Hard to Invert};
\end{tikzpicture}
\caption{\DIFadd{Visulizing One-way Funcations}}
\label{fig:owf}
\end{marginfigure}


\footnotetext{\DIFadd{Typically, the probability is only taken over the random choices of $x$, since we can fix the random coins of the adversary $\mathcal{A}$ that maximize its advantage.}}

\DIFadd{We note that the function is not necessarily one-to-one. In other words, it is possible that $f(x) = f(x')$ for $x \neq x'$ -- and the adversary is allowed to output any such $x'$.
}

\DIFadd{The above definition is rather delicate. We next describe problems in the slight variants of this definition that are insecure.
}

\begin{enumerate}
\item \DIFadd{What if we require that
    $\Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{A}(1^n, f(x)) \in f^{-1}(f(x))] = 0$ instead of being negligible?
}

\DIFadd{This condition is false for every function $f$. An adversary $\mathcal{A}$ that outputs an arbitrarily fixed value $x_0$ succeeds with probability at least $1/2^{n}$, as $x_0 = x$ with at least the same probability.
}

\item  \DIFadd{What if we drop the input $1^n$ to $\mathcal{A}$ in Equation~\ref{eq:owf}?
}

\DIFadd{Consider the function $f(x) = |x|$.  In this case, we have that $m = \log_2 n$, or $n = 2^m$.  Intuitively, $f$ should not be considered a one-way function, because it is easy to invert $f$. Namely, given a value $y$ any $x$ such that $|x| = y$ is such that $x \in f^{-1}(y)$.  However, according to this definition the adversary gets an $m$ bit string as input, and hence is restricted to running in time polynomial in $m$. Since each possible $x$ is of size $n = 2^m$, the adversary doesn't even have enough time to write down the answer!  Thus, according to the flawed definition above, $f$ would be a one-way function.
}

\DIFadd{Providing the attacker with $1^n$ ($n$ repetitions of the $1$ bit) as additional input avoids this issue.  In particular, it allows the attacker to run in time polynomial in $m$ and $n$.
}\end{enumerate}

\paragraph{\DIFadd{Candidate One-way Functions.}}
\DIFadd{It is not known whether one-way functions exist. In fact, the existence of one-way functions would imply that $P \neq NP$ (see Exercise~\ref{ex:PNP}). 
}

\DIFadd{However, there are candidates of functions that could be one-way functions, based on the difficulty of certain computational problems. (See Section~\ref{sec:assumptions})%DIF > One example is based on the hardness of factoring. Multiplication can be done easily in $O(n^2)$ time, but so far no polynomial time algorithm is known for factoring.
%DIF > Explicitly, we can define the function $f_1 : P_n \times P_n \rightarrow \mathbb{Z}$ where $P_n$ is the set of all $n$-bit primes as $f_1(p, q) = p \cdot q$.
%DIF > 
%DIF >  One candidate might be to say that given an input $x$, split $x$ into its left and right halves $x_1$ and $x_2$, and then output $x_1 \times x_2$.  However, this is not a one-way function, because with probability $\frac{3}{4}$, $2$ will be a factor of $x_1 \times x_2$, and in general the factors are small often enough that a non-negligible number of the outputs could be factored in polynomial time.
}

%DIF >  To improve this, we again split $x$ into $x_1$ and $x_2$, and use $x_1$ and $x_2$ as seeds in order to generate large primes $p$ and $q$, and then output $pq$.  Since $p$ and $q$ are primes, it is hard to factor $pq$, and so it is hard to retrieve $x_1$ and $x_2$.  This function is believed to be one-way.

%DIF > Another candidate is based on the hardness of the discrete logarithm problem. Given a group $\mathbb{G}$ of prime order $q$ and a generator $g$, the discrete logarithm problem is to find $x$ such that $g^x = y$ for a given $y$. The function $f_2 : \mathbb{Z}_q \rightarrow \mathbb{G}$ defined as $f_2(x) = g^x$ is also believed to be one-way assuming the hardness of the discrete logarithm problem.
%DIF > 
%DIF > 
%DIF > \section{OWFs from Discrete-Log}
\DIFadd{Let's suppose that the discrete-log assumption hold for group ensemble $\mathcal{G} = \{\mathbb{G}_n\}$ then we have that the function family $\{f_n\}$ where $f_n: \{1,\ldots |\mathbb{G}_n|\}\rightarrow \mathbb{G}_n$ is a one-way function family. In particular, $f_n(x) = g^x$ where $g$ is the generator of the group $\mathbb{G}_n$. The proof that $\{f_n\}$ is one-way based on the Discrete-Log Assumption (see Definition~\ref{def:dl}) is left as as an exercise. 
}


\section{\DIFadd{Robustness and Brittleness of One-way Functions}}
\DIFadd{What operations can we perform on one-way functions and still have a one-way function? In this section, we explore the robustness and brittleness of one-way functions and some operations that are safe or unsafe to perform on them.
}

\subsection{\DIFadd{Robustness}}
\DIFadd{Consider having a one-way function $f$.  Can we use this function $f$ in order to make a more structured one-way function $g$ such that $g(x_0) = y_0$ for some constants $x_0, y_0$, or would this make the function no longer be one-way? 
}

\DIFadd{Intuitively, the answer is yes - we can specifically set $g(x_0) = y_0$, and otherwise have $g(x) = f(x)$.  In this case, the adversary gains the knowledge of how to invert $y_0$, but that will only happen with negligible probability, and so the function is still one-way.
}

%DIF >  \begin{theorem}
%DIF >  Given a one-way function $f : \binset{n} \rightarrow \binset{m}$ and constants $x_0 \in \binset{n}$, $y_0 \in \binset{m}$, $\exists g : \binset{n} \rightarrow \binset{m}$ such that $g(x_0) = y_0$ where $g$ is a one-way function.
%DIF >  \end{theorem}

\DIFadd{In fact, this can be done for an exponential number of $x_0, y_0$ pairs. To illustrate that, consider the following function:
}\[
  \DIFadd{g(x_1\|x_2) = \left\{ \begin{array}{ll} x_1\|x_2 & : x_1 = 0^{n/2} \\ f(x_1\|x_2) & : \text{otherwise} \end{array} \right.
}\]

\DIFadd{However, this raises an apparent contradiction - according to this theorem, given a one-way function $f$, we could keep fixing each of its values to $0$, and it would continue to be a one-way function.  If we kept doing this, we would eventually end up with a function which outputs 0 for }{\em \DIFadd{all}} \DIFadd{of the possible values of $x$.  How could this still be one-way?}\\

\DIFadd{The resolution of this apparent paradox is by noticing that a one-way function is only required to be one-way in the limit where $n$ grows very large.  So, no matter how many times we fix the values of $f$ to be 0, we are still only setting a finite number of $x$ values to 0.  However, this will still satisfy the definition of a one-way function - it is just that we will have to use larger and larger values of $n_0$ in order to prove that the probability of breaking the one-way function is negligible.
}

\subsection{\DIFadd{Brittleness}}
\paragraph{\DIFadd{Example: OWFs do not always compose securely.}}
\DIFadd{Given a one-way function $f : \binfunc{n}{n}$, is the function $f^2(x) = f(f(x))$ also a one-way function?  Intuitively, it seems that if it is hard to invert $f(x)$, then it would be just as hard to invert $f(f(x))$. 
%DIF >  \sanjam{Explain the intuitive reduction that doesn't work.}  
However, this intuition is incorrect and highlights the delicacy when working with cryptographic assumptions and primitives. In particular, assuming one-way functions exists we describe a one-way function $f: \{0,1\}^{n}\times \{0,1\}^{n} \rightarrow \{0,1\}^{2n}$ such that $f^2$ can be efficiently inverted.
Let $g: \{0,1\}^n \rightarrow \{0,1\}^n$ be a one-way function then we set $f$ as follows:
}$$\DIFadd{f(x_1,x_2) = 0^{n}\|g(x_1)}$$
\DIFadd{Two observations follow:
}\begin{enumerate} 
  \item \DIFadd{$f^2$ is not one-way. This follows from the fact that for all inputs $x_1, x_2$ we have that $f^2(x_1,x_2) = 0^{2n}$. This function is clearly not one-way!
  }\item \DIFadd{$f$ is one-way. This can be argued as follows. Assume that there exists an adversary $\mathcal{A}$ such that $\mu_{\mathcal{A},f}(n) = \Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{A}(1^{2n}, f(x)) \in f^{-1}(f(x))]$ is non-negligible. Using such an $\mathcal{A}$ we will describe a construction of adversary $\mathcal{B}$ such that $\allowbreak\mu_{\mathcal{B},g}(n) = \Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{B}(1^n, g(x)) \in g^{-1}(g(x))]$ is also non-negligible. This would be a contradiction thus proving our claim.
}

      \textbf{\DIFadd{Description of $\mathcal{B}$}}\DIFadd{: $\mathcal{B}$ on input $y \in\{0,1\}^n$ outputs the $n$ lower-order bits of  $\mathcal{A}(1^{2n}, 0^{n}\|y)$.
}

      \DIFadd{Observe that if $\mathcal{A}$ successfully inverts $f$ then we have that $\mathcal{B}$ successfully inverts $g$. More formally, we have that:
      }$$\DIFadd{\mu_{\mathcal{B},g}(n) = \Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}\left[ \mathcal{A}(1^{2n}, 0^n || g(x)) \in \{0,1\}^n || g^{-1}(g(x))\right].}$$
      \DIFadd{But
      }\begin{align*}
      \DIFadd{\mu_{\mathcal{A},f}(2n) =}& \DIFadd{\Pr_{x_1, x_2 \stackrel{\$}{\leftarrow} \binset{2n}}[ \mathcal{A}(1^{2n}, f(x_1, x_2)) \in f^{-1}(f(\tilde x))]}\\
      \DIFadd{= }& \DIFadd{\Pr_{x_1 \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{A}(1^{2n}, 0^n || g(x_2)) \in \{0,1\}^n || g^{-1}(g(x_2))] }\\
      \DIFadd{= }& \DIFadd{\mu_{\mathcal{B},g}(n).
      }\end{align*}
      \DIFadd{Hence, we have that $\mu_{\mathcal{B},g}(n) = \mu_{\mathcal{A},f}(2n)$ which is non-negligible as long as $\mu_{\mathcal{A},f}(2n)$  is non-negligible.
}\end{enumerate}


%DIF > \begin{lemma}
%DIF > If $f : \binfunc{n}{n}$ is a one-way function, then $g : \binfunc{2n}{2n}$ defined as $g(x) = 0^n \concat f(x_{[1:n]})$ is also one-way.\\
%DIF > \end{lemma}
%DIF > \proof
%DIF > Assume towards contradiction that $g$ is not one-way, and so there is an adversary $A_g$ that inverts $g$ with probability $\mu(2n)$ that is non-negligible.\\
%DIF > 
%DIF > Note that $\mu(2n)$ is also non-negligible with respect to inputs of size $n$.\\

%DIF > Then we can define an adversary $A_f$ such that $A_f(y) = (A_g(0^n \concat y))_{[1:n]}$.  Note that $A_g$ breaks $g$ on input $0^n \concat y$ $\implies$ $A_f$ breaks $f$ on input $y$, and so $A_f$ breaks $f$ with at least non-negligible probability $\mu(2n)$.  Contradiction.\\
%DIF > 
%DIF > Thus, $g$ is also one-way.  \qed\\
%DIF > 
%DIF > Now, given a function $f : \binfunc{n}{n}$, we can construct a new one-way function $g : \binfunc{2n}{2n}$.  From $g$, we can construct another one-way function $h : \binfunc{2n}{2n}$ defined by:
%DIF > 
%DIF > $h(x) = \left\{
%DIF > \begin{array}{lr}
%DIF >   0^{2n} & : x_{[1:n]} = 0^n \\
%DIF >   g(x) & : otherwise
%DIF > \end{array}
%DIF > \right.$

%DIF > A generalization of the previous theorem (fixing values in a one-way function) shows that $h$ is also a one-way function.  (In short, we are only fixing the values of $\frac{2^n}{2^{2n}} = \frac{1}{2^n}$ of all of the possible values of $x$.  Since we are only fixing a negligible fraction of the possible values of $x$, the same proof with slight modifications still applies.)\\
%DIF > 
%DIF > So, $h$ is a one-way function.  However, $h^2(x) = h(h(x)) = 0^{2n}$, and so $h^2$ is clearly not a one-way function.  Thus, composing one-way functions is not guaranteed to give another one-way function. \qed

%DIF > \usepackage[utf8]{inputenc}
%DIF > \usepackage{amsmath,amssymb,fullpage}


%DIF >  The goal of this section is to illustrate the general strategy for the problems of the form,
%DIF >  \begin{center}
%DIF >  \textit{``If $f$ is one-way function, then show that $f'$ (derived from $f$) is not a one-way function"}
%DIF >  \end{center}
%DIF >  Some of the examples include:
%DIF >  \begin{itemize}
%DIF >  \item If $f$ is a one-way function, prove that $f'$ defined as $f(f(\cdot))$ is not one-way.
%DIF >  \item If $f$ is a one-way function, prove that $f'$ defined by dropping the first bit the output of $f$ is not one-way.
%DIF >  \end{itemize}

%DIF >  In order to give such a proof, we need to give an example of an one-way function $f$ and show that $f'$ (derived from $f$) is not one-way. The general strategy for these types of problems is the following:
%DIF >  \begin{enumerate}
%DIF >  \item Come up with a contrived function $g$ and show that $g$ is one-way. 
%DIF >  \item Construct the new function $g'$ that is derived from $g$.
%DIF >  \item Show that $g'$ can be inverted with non-negligible probability and thus show that $g'$ is not one-way.
%DIF >  \end{enumerate}
%DIF >  The reason why we need to come-up with a contrived function is that for specific one-way function $f$, $f'$ (derived from $f$) could be one-way. To see why this is the case, consider a one-way function $f: \bin^n \rightarrow \bin^n$ that is additionally injective. Then, one can show that $f^2(\cdot)$ is in fact a one-way function.\footnote{Try to prove this!} On the other hand, in the previous section, we showed that there exists a (contrived) function $g$ such that $g$ is one-way but $g^2$ is not one-way.
%DIF >  Hence, we might not always be able to start from any one-way function $f$ and show that $f'$ (derived from $f$) is not one-way. The first step where we come up a suitable $g$ requires some ingenuity. Once that is done, the second and the third steps would generally be not so hard.

%DIF >  To illustrate these three steps, let us consider a concrete example. 

\paragraph{\DIFadd{Example: Dropping a bit is not always secure.}}
\DIFadd{Below is another example of a transformation that does not work. Given any one-way function $g$, let $g'(x)$ be $g(x)$ with the first bit omitted.
}

\begin{claim}
\DIFadd{$g'$ is not necessarily one-way. In other words, there exists a OWF function $g$ for which $g'$ is not one-way.
}\end{claim}
\begin{proof}
\DIFadd{We must (1) construct a function $g$, (2) show that $g$ is one-way, and (3) show that $g'$ is not one-way.
}


\noindent\textbf{\DIFadd{Step 1: Construct a OWF $g$.}} 
\DIFadd{To do this, we first want to come up with a (contrived) function $g$ and prove that it is one-way.
Let us assume that there exists a one-way function $h : \bin^n \rightarrow \bin^n$. We define the function $g : \bin^{2n} \rightarrow \bin^{2n}$ as follows:
}$$
\DIFadd{g(x\|y) = \begin{cases}
 0^{n}\|y &\text{    if } x = 0^n\\
1\|0^{n-1}\|g(y) &\text{    otherwise }
\end{cases}
}$$

\noindent\textbf{\DIFadd{Step 2: Prove that $g$ is one-way.}}

\begin{claim}
\DIFadd{If $h$ is a one-way function, then so is $g$.
}\end{claim}
\begin{proof}
\DIFadd{Assume for the sake of contradiction that $g$ is not one-way. Then there exists a polynomial time adversary $\adv$ and a non-negligible function $\mu(\cdot)$ such that:
}$$
\DIFadd{\Pr_{x,y}[\adv(1^n,g(x\|y)) \in g^{-1}(g(x\|y))] = \mu(n)
}$$
\DIFadd{We will use such an adversary $\adv$ to invert $h$ with some non-negligible probability. This contradicts the one-wayness of $h$ and thus our assumption that $g$ is not one-way function is false.
}

\DIFadd{Let us now construct an $\advb$ that uses $\adv$ and inverts $h$. $\advb$ is given $1^n,h(y)$ for a randomly chosen $y$ and its goal is to output $y' \in h^{-1}(h(y))$ with some non-negligible probability. $\advb$ works as follows:
}\begin{enumerate}
\item \DIFadd{It samples $x \gets \bin^n$ randomly.
}\item \DIFadd{If $x = 0^n$, it samples a random $y' \gets \bin^n$ and outputs it.
}\item \DIFadd{Otherwise, it runs $\adv(10^{n-1}\|h(y))$ and obtains $x' \| y'$. It outputs $y'$.
}\end{enumerate}

\DIFadd{Let us first analyze the running time of $\advb$. The first two steps are clearly polynomial (in $n$) time. In the third step, $\advb$ runs $\adv$ and uses its output. Note that the running time of since $\adv$ runs in polynomial (in $n$) time, this step also takes polynomial (in $n$) time. Thus, the overall running time of $\advb$ is polynomial (in $n$).
}

\DIFadd{Let us now calculate the probability that $\advb$ outputs the correct inverse. If $x = 0^n$, the probability that $y'$ is the correct inverse is at least $\frac{1}{2^n}$ (because it guesses $y'$ randomly and probability that a random $y'$ is the correct inverse is $\geq 1/2^n$). On the other hand, if $x \neq 0^n$, then the probability that $\advb$ outputs the correct inverse is $\mu(n)$. Thus,
}\begin{eqnarray*}
\DIFadd{\Pr[\advb(1^n,h(y)) \in h^{-1}(h(y))] }& \DIFadd{\geq }& \DIFadd{\Pr[x = 0^n](\frac{1}{2^n}) + \Pr[x \neq 0^n]\mu(n)}\\
& \DIFadd{= }& \DIFadd{\frac{1}{2^{2n}} + (1 - \frac{1}{2^n}) \mu(n) }\\
& \DIFadd{\geq }& \DIFadd{\mu(n) - (\frac{1}{2^{n}} - \frac{1}{2^{2n}})
}\end{eqnarray*}

\DIFadd{Since $\mu(n)$ is a non-negligible function and $(\frac{1}{2^{n}} - \frac{1}{2^{2n}})$ is a negligible function, their difference is non-negligible.}\footnote{\DIFadd{Exercise: Prove that if $\alpha(\cdot)$ is a non-negligible function and $\beta(\cdot)$ is a negligible function, then $(\alpha - \beta)(\cdot)$ is a non-negligible function.}} \DIFadd{This contradicts the one-wayness of $h$.
}

\end{proof} 


\noindent\textbf{\DIFadd{Step 3: Prove that $g'$ is not one-way.}} 
\DIFadd{We construct the new function $g': \bin^{2n} \rightarrow \bin^{2n-1}$ by dropping the first bit of $g$. That is,
}$$
\DIFadd{g'(x\|y) = \begin{cases}
 0^{n-1}\|y &\text{    if } x = 0^n\\
0^{n-1}\|g(y) &\text{    otherwise }
\end{cases}
}$$

\DIFadd{We now want to prove that $g'$ is not one-way. That is, we want to design an adversary $\advc$ such that given $1^{2n}$ and $g'(x \| y)$ for a randomly chosen $x,y$, it outputs an element in the set $g^{-1}(g(x \| y)$. The description of $\advc$ is as follows:
}

\begin{itemize}
\item \DIFadd{On input $1^{2n}$ and $g'(x \| y)$, the adversary $\advc$ parses $g'(x \| y)$ as $0^{n-1} \| \overline{y}$.
}\item \DIFadd{It outputs $0^{n} \| \overline{y}$ as the inverse.
}\end{itemize}
\DIFadd{Notice that $g'(0^{n} \| \overline{y}) = 0^{n-1} \| \overline{y}$. Thus, $\advc$ succeeds with probability $1$ and this breaks the one-wayness of $g'$.
}

\end{proof}


%DIF > %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\DIFadd{Hardness Amplification}}
\label{sec:owf:amplify}
\DIFadd{In this section, we show that even a very }\emph{\DIFadd{weak}} \DIFadd{form of one-way functions suffices from constructing one-way functions as defined previously. For this section, we refer to this previously defined notion as strong one-way functions.
}\begin{definition}[Weak One-Way Functions]
\DIFadd{A function $f : \binset{n} \rightarrow \binset{m}$ is said to be a weak one-way function if:
}\begin{itemize}
\item[\DIFadd{-}] \DIFadd{$f$ is computable by a polynomial time machine, and
}\item[\DIFadd{-}] \DIFadd{There exists a noticeable function $\alpha_f(\cdot)$ such that $\forall$ non-uniform PPT adversaries $\mathcal{A}$ we have that
    }$$
    \DIFadd{\mu_{\mathcal{A},f}(n) =
    \Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{A}(1^n, f(x)) \in f^{-1}(f(x))] \leq 1 - \alpha_{f}(n).
    }$$
\end{itemize}
\end{definition}

\begin{theorem}\label{theorem:weakstrongOWF}
\DIFadd{If there exists a weak one-way function, then there exists a (strong) one-way function.
}\end{theorem}

\proof \DIFadd{We prove the above theorem constructively. Suppose $f : \binset{n} \rightarrow \binset{m}$ is a weak one-way function, then we prove that the function $g: \binset{nq} \rightarrow \binset{mq}$ for $q = \lceil \frac{2n}{\alpha_{f}(n)} \rceil$ where 
}$$\DIFadd{g(x_1, x_2, \cdots, x_q) = f(x_1) || f(x_2) || \cdots || f(x_q),}$$
 \DIFadd{is a strong one-way function. Let us discuss the intuition. A weak one-way function is "strong" in a small part of its domain. For this construction to result in a strong one-way function, we need just one of the $q$ instantiations to be in the part of the domain where our weak one-way function is strong. If we pick a large enough $q$, this is guaranteed to happen.
}

\DIFadd{Assume for the sake of contradiction that there exists an adversary $\mathcal{B}$ such that $\mu_{\mathcal{B},g}(nq) = \Pr_{x \stackrel{\$}{\leftarrow} \binset{nq}}[ \mathcal{B}(1^{nq}, g(x)) \in g^{-1}(g(x))]$ is non-negligible.
%DIF > Suppose $\mu_{\mathcal{A},g}(nq) \geq \tilde \mu_{\mathcal{A},g}(nq)$ for arbitrarily large $n$, where $\tilde  \mu_{\mathcal{A},g}$ is a noticeable function.\peihan{to ensure that $T$ is poly}
Then we use $\mathcal{B}$ to construct $\mathcal{A}$ (see Figure~\ref{fig:adv:weak}) that breaks $f$, namely $\mu_{\mathcal{A},f}(n) = \Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{A}(1^n, f(x)) \in f^{-1}(f(x))] > 1 - \alpha_f(n)$ for sufficiently large $n$.
}\begin{marginfigure}[-5cm]
%DIF > \Loop { $T=\frac{4n^2}{\alpha_f(n) \mu_{\mathcal{B}, g}(nq)}$ times}
\begin{enumerate}
    \item \DIFadd{$i \stackrel{\$}{\leftarrow} [q]$.
    }\item \DIFadd{$x_1, \cdots, x_{i-1}, x_i, \cdots, x_q \stackrel{\$}{\leftarrow} \binset{n}$.
    }\item \DIFadd{Set $y_j = f(x_j)$ for each $j \in [q]\backslash \{i\}$ and $y_i = y$.
    }\item \DIFadd{$(x'_1, x'_2, \cdots, x'_q) := \mathcal{B} (f(x_1), f(x_2), \cdots, f(x_q))$.
    }\item {\DIFadd{$f(x'_i) = y$}} \DIFadd{then output $x'_i$ else $\bot$.
}\end{enumerate}
\caption{\DIFadd{Construction of $\mathcal{A}(1^n, y)$}}
\label{fig:adv:weak}
\end{marginfigure}

\DIFadd{Note that: (1) $\mathcal{A}(1^n, y)$ iterates at most $T = \frac{4n^2}{\alpha_f(n)\mu_{\mathcal{B},g}(nq)}$ times each call is polynomial time. (2) $\mu_{\mathcal{B},g}(nq)$ is a non-negligible function. This implies that for infinite choices of $n$ this value is greater than some noticeable function. Together these two facts imply that for infinite choices of $n$ the running time of $\mathcal{A}$ is bounded by a polynomial function in $n$.
}

\DIFadd{It remains to show that $\Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{A}(1^n, f(x)) = \bot] < \alpha_f(n)$ for arbitrarily large $n$. A natural way to argue this is by showing that at least one execution of $\mathcal{B}$ should suffice for inverting $f(x)$. However, the technical challenge in proving this formally is that these calls to $\mathcal{B}$ aren't independent. Below we formalize this argument even when these calls aren't independent.}\marginnote[-5cm]{\begin{lemma}
Let $A$ be any an efficient algorithm such that $\Pr_{x,r}[A(x,r) =1] \geq \epsilon$. Additionally, let $G = \{x\mid \geq \Pr_{r}[A(x,r) =1] \geq \frac{\epsilon}{2}\}$. Then, we have $\Pr_x[x \in G] \geq \frac{\epsilon}{2}$.
\end{lemma}
\begin{proof}
The proof of this lemma follows by a very simple counting argument. Let's start by assuming that $\Pr_x[x \in G] < \frac{\epsilon}{2}$. Next, observe that
\begin{align*}
\Pr_{x,r}&[A(x,r) =1]& \\&= \Pr_x[x \in G]\cdot\Pr_{x,r}[A(x,r) =1\mid x \in G] \\&+ \Pr_x[x \not\in G]\cdot\Pr_{x,r}[A(x,r) =1\mid x \not\in G]
\\&< \frac{\epsilon}{2}\cdot 1 + 1\cdot\frac{\epsilon}{2}
\\&< \epsilon,
\end{align*}
which is a contradiction.
\end{proof}
}

\DIFadd{Define the set $S$ of ``bad'' $x$'s, which are hard to invert:
}$$\DIFadd{S := \left\{x \left| \Pr_\mathcal{B}\left[\mathcal{A} \text{ inverts $f(x)$ in a single iteration} \right] \leq \frac{\alpha_f(n) \mu_{\mathcal{B},g}(nq)}{4n} \right. \right\}.}$$
\DIFadd{We start by proving that the size of $S$ is small. More formally,
}$$\DIFadd{\Pr_{x \stackrel{\$}{\leftarrow} \binset{n}} }[\DIFadd{x \in S}] \DIFadd{\leq \frac{\alpha_f(n)}{2}.}$$
\DIFadd{Assume, for the sake of contradiction,}\marginnote{\begin{lemma}
Let $A$ be any an efficient algorithm such that $\Pr_{x,r}[A(x_1,\ldots x_n,r) =1] \geq \epsilon$. Additionally, let $G = \{x\mid \geq \Pr_{x_1,\ldots x_n,r}[A(x,r) =1\mid \exists i, x = x_i] \geq \frac{\epsilon}{2}\}$. Then, we have $\Pr_x[x \in G] \geq \frac{\epsilon}{2}$.
\end{lemma}
\begin{proof}
The proof of this lemma follows by a very simple counting argument. Let's start by assuming that $\Pr_x[x \in G] < \frac{\epsilon}{2}$. Next, observe that
\begin{align*}
\Pr_{x,r}&[A(x,r) =1]& \\&= \Pr_x[x \in G]\cdot\Pr_{x,r}[A(x,r) =1\mid x \in G] \\&+ \Pr_x[x \not\in G]\cdot\Pr_{x,r}[A(x,r) =1\mid x \not\in G]
\\&< \frac{\epsilon}{2}\cdot 1 + 1\cdot\frac{\epsilon}{2}
\\&< \epsilon,
\end{align*}
which is a contradiction.
\end{proof}
}
\DIFadd{that $\Pr_{x \stackrel{\$}{\leftarrow} \binset{n}} [x \in S]  > \frac{\alpha_f(n)}{2}$. Then we have that:
}\begin{align*}
\DIFadd{\mu_{\mathcal{B},g}(nq) =}& \DIFadd{\Pr_{(x_1, \cdots, x_q) \stackrel{\$}{\leftarrow} \binset{nq}}[ \mathcal{B}(1^{nq}, g(x_1, \cdots, x_q)) \in g^{-1}(g(x_1, \cdots, x_q))]}\\
\DIFadd{=}&  \DIFadd{\Pr_{x_1, \cdots, x_q}[ \mathcal{B}(1^{nq}, g(x_1, \cdots, x_q)) \in g^{-1}(g(x_1, \cdots, x_q)) \wedge \forall i: x_i \notin S]}\\
& \DIFadd{+ \Pr_{x_1, \cdots, x_q}[ \mathcal{B}(1^{nq}, g(x_1, \cdots, x_q)) \in g^{-1}(g(x_1, \cdots, x_q)) \wedge \exists i: x_i \in S]}\\
\DIFadd{\leq}& \DIFadd{\Pr_{x_1, \cdots, x_q}[ \forall i: x_i \notin S]
+ \sum_{i=1}^q \Pr_{x_1, \cdots, x_q}[ \mathcal{B}(1^{nq}, g(x_1, \cdots, x_q)) \in g^{-1}(g(x_1, \cdots, x_q)) \wedge  x_i \in S]}\\
\DIFadd{\leq}& \DIFadd{\left( 1-\frac{\alpha_f(n)}{2}\right)^q
+ q \cdot \Pr_{x_1, \cdots, x_q,i}[ \mathcal{B}(1^{nq}, g(x_1, \cdots, x_q)) \in g^{-1}(g(x_1, \cdots, x_q)) \wedge x_i \in S] }\\
\DIFadd{=}& \DIFadd{\left( 1-\frac{\alpha_f(n)}{2}\right)^{\frac{2n}{\alpha_f(n)}}
+  q\cdot \Pr_{x \stackrel{\$}{\leftarrow} \binset{n}, \mathcal{B}}[\mathcal{A} \text{ inverts $f(x)$ in a single iteration}  \wedge x \in S]}\\
\DIFadd{\leq}& \DIFadd{e^{-n} + q\cdot  \Pr_{x}[x \in S] \cdot \Pr[\mathcal{A} \text{ inverts $f(x)$ in a single iteration} ~|~ x \in S]}\\
\DIFadd{\leq}& \DIFadd{e^{-n} + \frac{2n}{\alpha_f(n)} \cdot  1 \cdot \frac{\mu_{\mathcal{B},g}(nq) \cdot \alpha_f(n)}{4n}}\\
\DIFadd{\leq}& \DIFadd{e^{-n} + \frac{\mu_{\mathcal{B},g}(nq)}{2}.
}\end{align*}
\DIFadd{Hence $\mu_{\mathcal{B},g}(nq) \leq 2 e^{-n}$, contradicting with the fact that $\mu_{\mathcal{B},g}$ is non-negligible.
Then we have
}\begin{align*}
\DIFadd{\Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}}&[ \DIFadd{\mathcal{A}(1^n, f(x)) = \bot}]\\
\DIFadd{=}& \DIFadd{\Pr_x[x \in S] + \Pr_x }[\DIFadd{x \notin S}]\DIFadd{\cdot\Pr[\mathcal{B} \text{ fails to invert $f(x)$ in every iteration} | x \notin S]}\\
\DIFadd{\leq}& \DIFadd{\frac{\alpha_f(n)}{2}+ \left(\Pr[ \mathcal{B} \text{ fails to invert $f(x)$ a single iteration} | x \notin S] \right)^T}\\
\DIFadd{\leq }& \DIFadd{\frac{\alpha_f(n)}{2}+ \left( 1-\frac{\mu_{\mathcal{A},g}(nq) \cdot \alpha_f(n)}{4n}\right)^T}\\
\DIFadd{\leq}& \DIFadd{\frac{\alpha_f(n)}{2} + e^{-n} \leq \alpha_f(n)
}\end{align*}
\DIFadd{for sufficiently large $n$. This concludes the proof.
}\qed



\section{\DIFadd{Levin's One-Way Function}}

\DIFadd{In this section, we discuss Levin's one-way function, which is an explicit construction of a one-way function that is secure as long as a one-way function exists.
This is interesting because unlike a typical cryptographic primitive that relies on a specific hardness assumption (which may or may not hold in the future), Levin's one-way function is future-proof in the sense that it will be secure as long as atleast one hardness assumption holds (which we may or may not discover).
}

\DIFadd{The high-level intuition behind Levin's construction is as follows: since we assume one-way functions exist, there exists a uniform machine $\tilde M$ such that $|\tilde M|$ is a constant and $\tilde M(x)$ is hard to invert for a random input $x$.
Now, consider a function $h$ that parses the first $\log(n)$ bits of its $n$-bit input as the code of a machine $M$ and the remaining bits as the input to $M$.
For a large enough $n$ that is exponential in $|\tilde{M}|$, note that we will hit the code of $\tilde{M}$ with noticeable probability in $n$, and for those instances, $h$ will be hard to invert.
%DIF >  that if you parse the input to the function as the code of a uniform machine $M$ followed by the input to the machine, for large enough input length $n$ that is exponential in $|M|$, you'll get the code of a one-way function with some noticeable probability.
It is easy to see that this gives us a weak one-way function which has a noticeable probability of being hard to invert, and we can amplify the hardness of this weak one-way function to get an explicit construction of a one-way function.
}

\begin{theorem}\label{thm:levin}
\DIFadd{If there exists a one-way function, then there exists an explicit function $f$ that is one-way  (constructively).
}\end{theorem}

\DIFadd{Before we look at the construction and the proof in detail, we first prove a lemma that will be useful in the proof.
In particular, we need a bound on the running time of the one-way function $\tilde M$ so that we can upper bound the execution time of $h$, since there could be inputs to $g$ that do not terminate in polynomial time.
To this end, we prove the following lemma which shows that if a one-way function exists, then there is also a one-way function that runs in time $n^2$, and thus, we can bound $h$ to $n^2$ steps.
}

\begin{lemma}\label{lem:n2owf}
\DIFadd{If there exists a one-way function computable in time $n^c$ for a constant $c$, then there exists a one-way function computable in time $n^2$.
}\end{lemma}
\proof
\DIFadd{Let $f: \binset{n} \rightarrow \binset{n}$ be a one-way function computable in time $n^c$.
Construct $g: \binset{n+n^c} \rightarrow \binset{n+n^c}$ as follows:
}$$\DIFadd{g(x,y) = f(x) || y}$$
\DIFadd{where $x \in \binset{n}, y \in \binset{n^c}$.
$g(x,y)$ takes time $2n^c$, which is linear in the input length.
}

\DIFadd{We next show that $g(\cdot)$ is one-way.
Assume for the purpose of contradiction that there exists an adversary $\mathcal{A}$ such that $\mu_{\mathcal{A},g}(n+n^c) = \Pr_{(x,y) \stackrel{\$}{\leftarrow} \binset{n+n^c}}[ \mathcal{A}(1^{n+n^c}, g(x,y)) \in g^{-1}(g(x,y))]$ is non-negligible. Then we use $\mathcal{A}$ to construct $\mathcal{B}$ such that $\mu_{\mathcal{B},f}(n) = \Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{B}(1^n, f(x)) \in f^{-1}(f(x))]$ is also non-negligible.
}

\DIFadd{$\mathcal{B}$ on input $z \in\{0,1\}^n$, samples $y \stackrel{\$}{\leftarrow} \binset{n^c}$, and outputs the $n$ higher-order bits of  $\mathcal{A}(1^{n+n^c}, z||y)$. Then we have
}\begin{align*}
\DIFadd{\mu_{\mathcal{B},g}(n) =}& \DIFadd{\Pr_{x \stackrel{\$}{\leftarrow} \binset{n}, y \stackrel{\$}{\leftarrow} \binset{n^c}}\left[\mathcal{A}(1^{n+n^c}, f(x) || y) \in f^{-1}(f(x)) || \binset{n^c}\right]}\\
\DIFadd{\geq}&\DIFadd{\Pr_{x,y}\left[\mathcal{A}(1^{n+n^c}, g(x,y)) \in f^{-1}(f(x)) || y\right]}\\
\DIFadd{=}& \DIFadd{\Pr_{x,y}\left[\mathcal{A}(1^{n+n^c}, g(x,y)) \in g^{-1}(g(x,y))\right]
}\end{align*}
\DIFadd{is non-negligible.
}\qed

\bigskip
\DIFadd{Now, we provide the explicit construction of $h$ and prove that it is a weak one-way function.
Since $h$ is an (explicit) weak one-way function, we can construct an (explicit) one-way function from $h$ as we discussed in Section~\ref{sec:owf:amplify}, and this would prove Theorem~\ref{thm:levin}.
}\proof[Proof of Theorem~\ref{thm:levin}]
\DIFadd{$h: \binset{n} \rightarrow \binset{n}$ is defined as follows:
}$$
\DIFadd{h(M,x) = \left\{
\begin{array}{ll}
M || M(x) & \text{if $M(x)$ takes no more than $|x|^2$ steps} \\
M || 0 & \text{otherwise}
\end{array}
\right.
}$$
\DIFadd{where $|M| = \log n, |x| = n - \log n$ (interpreting $M$ as the code of a machine  and $x$ as its input).
}

\DIFadd{It remains to show that if one-way functions exist, then $h$ is a weak one-way function, with $\alpha_h(n) = \frac{1}{n^2}$.
Assume for the purpose of contradiction that there exists an adversary $\mathcal{A}$ such that $\mu_{\mathcal{A},h}(n) = \Pr_{(M,x) \stackrel{\$}{\leftarrow} \binset{n}}[ \mathcal{A}(1^{n}, h(M,x)) \in h^{-1}(h(M,x))]\geq 1-\frac{1}{n^2}$ for all sufficiently large $n$.
By the existence of one-way functions and Lemma~\ref{lem:n2owf}, there exists a one-way function $\tilde M$ that can be computed in time $n^2$. Let $\tilde M$ be the uniform machine that computes this one-way function.
We will consider values $n$ such that $n > 2^{|\tilde M|}$. In other words for these choices of $n$, $\tilde M$ can be described using $\log n$ bits.
We construct $\mathcal{B}$ to invert $\tilde M$: on input $y$ outputs the $(n-\log n)$ lower-order bits of $\mathcal{A}(1^n, \tilde M||y)$. Then
}\begin{align*}
\DIFadd{\mu_{\mathcal{B},\tilde M}(n-\log n) =}& \DIFadd{\Pr_{x \stackrel{\$}{\leftarrow} \binset{n-\log n}}\left[\mathcal{A}(1^{n}, \tilde M || \tilde M(x)) \in \binset{\log n} || \tilde M^{-1}(\tilde M((x))\right]}\\
\DIFadd{\geq}& \DIFadd{\Pr_{x \stackrel{\$}{\leftarrow} \binset{n-\log n}}\left[\mathcal{A}(1^{n}, \tilde M || \tilde M(x)) \in \tilde{M} || \tilde M^{-1}(\tilde M((x))\right].
}\end{align*}
\DIFadd{Observe that for sufficiently large $n$ it holds that
}\begin{align*}
\DIFadd{1-\frac{1}{n^2} \leq}& \DIFadd{\mu_{\mathcal{A},h}(n)}\\
\DIFadd{=}& \DIFadd{\Pr_{(M,x) \stackrel{\$}{\leftarrow} \binset{n}}\left[ \mathcal{A}(1^{n}, h(M,x)) \in h^{-1}(h(M,x))\right]}\\
\DIFadd{\leq}& \DIFadd{\Pr_{M }[M = \tilde M] \cdot \Pr_{x }\left[ \mathcal{A}(1^{n}, \tilde M||\tilde M(x)) \in  \tilde{M} || \tilde M^{-1}(\tilde M((x))\right] + \Pr_{M }[M \neq \tilde M]  }\\
\DIFadd{\leq}&  \DIFadd{\frac{1}{n} \cdot \mu_{\mathcal{B},\tilde M}(n-\log n) +\frac{n-1}{n}.
}\end{align*}
\DIFadd{Hence $\mu_{\mathcal{B},\tilde M}(n-\log n) \geq \frac{n-1}{n}$  for sufficiently large $n$ which is a contradiction.
}\qed

\section{\DIFadd{Hardness Concentrate Bit}}
\DIFadd{We start by asking the following question: Is it possible to concentrate the strength of a one-way function into one bit? In particular, given a one-way function $f$, does there exist one bit that can be computed efficiently from the input $x$, but is hard to compute given $f(x)$?
}\begin{definition}[Hard Concentrate Bit]
\DIFadd{Let $f:\binset{n} \rightarrow \binset{n}$ be a one-way function.
$B:\{0,1\}^n \rightarrow \{0,1\}$ is a hard concentrate bit of $f$ if:
}\begin{itemize}
\item[\DIFadd{-}] \DIFadd{$B$ is computable by a polynomial time machine, and
}\item[\DIFadd{-}] \DIFadd{$\forall$ non-uniform PPT adversaries $\mathcal{A}$ we have that
	}$$\DIFadd{\Pr_{x\stackrel{\$}{\leftarrow} \binset{n}}[\mathcal{A}(1^n, f(x)) = B(x)] \leq \frac{1}{2} + \mathsf{negl}(n).}$$
\end{itemize}
\end{definition}

\noindent\textbf{\DIFadd{A simple example.}}
\DIFadd{Let $f$ be a one-way function. Consider the one-way function $g(b, x) = 0 || f(x)$ and a hard concentrate bit $B(b, x) = b$.
Intuitively, the value $g(b, x)$ does not reveal any information about the first bit $b$, thus no information about the value $B(b, x)$ can be ascertained. Hence $\mathcal{A}$ cannot predict the first bit with a non-negligible advantage than a random guess. However, we are more interested in the case where the hard concentrate bit is hidden because of computational hardness and not information theoretic hardness.
}

\bigskip
\begin{remark}
\DIFadd{Given a one-way function $f$, we can construct another one-way function $g$ with a hard concentrate bit. However, we may not be able to find a hard concentrate bit for $f$. In fact, it is an open question whether a hard concentrate bit exists for every one-way function.
}\end{remark}

\bigskip
\DIFadd{Intuitively, if a function $f$ is one-way, it seems that there should be a particular bit in the input $x$ that is hard to compute given $f(x)$. However, we show that is not true:
}\begin{claim}
\DIFadd{If $f:\binset{n}\rightarrow \binset{n}$ is a one-way function, then there exists a one-way function $g:\binset{n+\log n}\rightarrow\binset{n+\log n}$ such that $\forall i \in [1, n+\log n]$, $B_i(x) = x_i$ is not a hard concentrate bit, where $x_i$ is the $i^\text{th}$ bit of $x$.
}\end{claim}
\proof
\DIFadd{Define $g:\{0,1\}^{n+\log(n)} \rightarrow \{0,1\}^{n+\log(n)}$ as follows.
}$$\DIFadd{g(x,y) = f(x_{\bar y}) || x_y || y,}$$
\DIFadd{where $|x| = n, |y| = \log n$, $x_{\bar y}$ is all bits of $x$ except the $y^\text{th}$ bit, and $x_y$ is the $y^\text{th}$ bit of $x$.
}

\DIFadd{First, one can show that $g$ is still a one-way function. (We leave this as an exercise!)
Next, we show that $B_i$ is not a hard concentrate bit for $\forall i \in [1, n]$ (clearly $B_i$ is not a hard concentrate bit for $i \in [n+1, n+\log n]$).
Construct an adversary $\mathcal{A}_i(1^{n+\log n}, f(x_{\bar y}) || x_y || y)$ that ``breaks'' $B_i$:
}\begin{itemize}
\item[\DIFadd{-}] \DIFadd{If $y \not= i$ then output a random bit;
}\item[\DIFadd{-}] \DIFadd{Otherwise output $x_y$.
}\end{itemize}
\begin{align*}
& \DIFadd{\Pr_{x, y}[\mathcal{A}(1^{n+\log n}, g(x,y)) = B_i(x)]}\\
\DIFadd{=}& \DIFadd{\Pr_{x, y}[\mathcal{A}(1^{n+\log n}, f(x_{\bar y}) || x_y || y) = x_i]}\\
\DIFadd{=}& \DIFadd{\frac{n-1}{n} \cdot \frac{1}{2} + \frac{1}{n} \cdot 1 = \frac{1}{2} + \frac{1}{2n}.
}\end{align*}
\DIFadd{Hence $\mathcal{A}_i$ can guess the output of $B_i$ with greater than $\frac{1}{2} + \mathsf{negl}(n)$ probability.
}\qed


\DIFaddend \iffalse
\DIFaddbegin \paragraph{\DIFadd{Application: Coin tossing over the phone.}} \DIFadd{We next describe an application of hard concentrate bits to coin tossing.
Consider two parties trying to perform a coin tossing over the phone. In this setting the first party needs to declare its choice as the second one flips the coin. However, how can the first party trust the win/loss response from the second party?  In particular, if the first party calls out ``head'' and then the second party can just lie that it was ``tails.'' We can use hard concentrate bit of a (one-to-one) one-way function to  enable this applications.
}\DIFaddend 

\DIFdelbegin %DIFDELCMD < \input{Old Scribe Notes/ram}
%DIFDELCMD < %%%
%DIF <  IO
\DIFdelend \DIFaddbegin \DIFadd{Let $f$ be a (one-to-one) one-way function and $B$ be a hard concentrate bit for $f$. Consider the following protocol:
}\begin{itemize}
\item[\DIFadd{-}] \DIFadd{Party $P_1$ samples $x$ from $\{0,1\}^n$ uniformly at random and sends $y$, where $y = f(x)$, to party $P_2$.
}\item[\DIFadd{-}] \DIFadd{$P_2$ sends back a random bit $b$ sampled from $\{0,1\}$.
}\item[\DIFadd{-}] \DIFadd{$P_1$ sends back $(x, B(x))$ to $P_2$. $P_2$ aborts if $f(x) \neq y$.
}\item[\DIFadd{-}]  \DIFadd{Both parties output $B(x)\oplus b$.
}\end{itemize}
\DIFadd{Note that $P_2$ cannot guess $B(x)$ with a non-negligible advantage than $1/2$ as he sends back his $b$.
On the other hand, $P_1$ cannot flip the value $B(x)$ once it has sent $f(x)$ to $P_2$ because $f$ is one-to-one.
}\fi
\DIFaddend 

%DIF < \chapter{Fully-Homomorphic Encryption}
%DIF < \begin{itemize}
%DIF < 	\item $(KeyGen, Enc, Dec, Eval)$
\DIFaddbegin \subsection{\DIFadd{Hard Concentrate Bit of any One-Way Permutation}}
\DIFadd{We now show that a slight modification of every one-way function has a hard concentrate bit. More formally,
}\begin{theorem}\label{thm:hard-concentrate-bit}
\DIFadd{Let  $f:\binset{n} \rightarrow \binset{n}$ be a one-way function.
Define a function $g:\binset{2n} \rightarrow \binset{2n}$ as follows:
}$$\DIFadd{g(x,r) = f(x) || r,}$$
\DIFadd{where $|x| = |r| =n$. Then we have that $g$ is one-way and that it has a hard concentrate bit, namely $B(x, r) = \sum_{i=1}^n x_i r_i\mod 2$.
}\end{theorem}
\begin{remark}
\DIFadd{If $f$ is a (one-to-one) one-way function, then $g$ is also a (one-to-one) one-way function with hard concentrate bit $B(\cdot)$.
}\end{remark}
\proof
\DIFadd{We leave it as an exercise to show that $g$ is a one-way function and below we will prove that the function $B(\cdot)$ describe a hard concentrate bit of $g$.
More specifically, we need to show that if there exists a non-uniform PPT  $\ma$ s.t. $\Pr_{x,r}[\ma(1^{2n},g(x,r)) = B(x,r)] \ge \frac{1}{2} + \epsilon(n)$, where $\epsilon$ is non-negligible, then there exists a non-uniform PPT $\mathcal{B}$ such that $\Pr_{x,r}[\mathcal{B}(1^{2n}, g(x,r)) \in g^{-1}(g(x,r))]$ is non-negligible.
Below we use $E$ to denote the event that $\ma(1^{2n},g(x,r)) = B(x,r)$.
We will present our proof in three steps, where each step progressively increases in complexity:
(1) the super simple case where we restrict to $\ma$ such that $\Pr_{x,r}[E] = 1$,
(2) the simple case where we restrict to $\ma$ such that $\Pr_{x,r}[E] \geq \frac{3}{4} + \epsilon(n)$,
and finally (3) the general case where $\Pr_{x,r}[E] \geq \frac{1}{2} + \epsilon(n)$.
}

\medskip
\noindent\textbf{\underline{\DIFadd{Super simple case.}}}
\DIFadd{Suppose $\ma$ guesses $B(\cdot)$ with perfect accuracy:
}$$\DIFadd{\Pr_{x,r}[E] =1.}$$
\DIFadd{We now construct $\mathcal{B}$ that inverts $g$ with perfect accuracy.
Let $e^i$ denote the one-hot $n$-bit string $0\cdots 0 1 0 \cdots0$, where only the $i$-th bit is $1$, the rest are all $0$.
$\mathcal{B}$ gets $f(x)||r$ as input, and its algorithm is described in Figure~\ref{alg:super-simple-case}.
}

\begin{marginfigure}
\begin{algorithmic}
\For {\DIFadd{$i=1$ }\textbf{\DIFadd{to}} \DIFadd{$n$}}
    \State \DIFadd{$x'_i \gets \ma(1^{2n}, f(x)||e^i)$
}\EndFor
\State \Return \DIFadd{$x'_1\cdots x'_n || r$
}\end{algorithmic}
\caption{\DIFadd{Super-Simple Case $\mathcal{B}$}} \label{alg:super-simple-case}
\end{marginfigure}
\DIFadd{Observe that $B(x,e^i) = \sum_{j=1}^n x_je^i_j = x_i$. Therefore, the probability that $\mathcal{B}$ inverts a single bit successfully is,
}$$\DIFadd{\Pr_{x}\left[\ma(1^{2n}, f(x)||e^i)=x_i\right] =  \Pr_{x}\left[\ma(1^{2n}, f(x)||e^i)=B(x,e^i)\right] = 1.}$$
\DIFadd{Hence $\Pr_{x,r}[\mathcal{B}(1^{2n}, g(x,r)) = (x,r)] = 1$.
}


\bigskip
\noindent\textbf{\underline{\DIFadd{Simple case.}}}
\DIFadd{Next moving on to the following more demanding case.
}$$\DIFadd{\Pr_{x,r}[E] \geq \frac{3}{4} + \epsilon(n),}$$ \DIFadd{where $\epsilon(\cdot)$ is non-negligible.
We describe $\mathcal{B}$'s algorithm for inverting $g$ in Figure~\ref{alg:simple-case}.
Here we can no longer use the super simple case algorithm because we no longer know if $\ma$ outputs the correct bit on input $f(x) \| e^i$.
Instead, we introduce randomness to $\ma$'s input expecting that it should be able to guess the right bit on majority of those inputs since it has a high probability of guessing $B(\cdot)$ in general.
We now also need to make two calls to $\ma$ to isolate the $i$-th bit of $x$.
%DIF >  On input $f(x)||r$, $\mathcal{B}$ proceeds as follows:
Note that an iteration of $\mathcal{B}$ outputs the right bit if calls to $\ma$ output the correct bit because $B(x,s) \oplus B(x, s\oplus e^i) = x_i$:
}\begin{marginfigure}
\begin{algorithmic}
\For {\DIFadd{$i = 1$ }\textbf{\DIFadd{to}} \DIFadd{$n$}}
	\For {\DIFadd{$t = 1$ }\textbf{\DIFadd{to}} \DIFadd{$T = \frac{n}{2\epsilon(n)^2}$}}
		\State \DIFadd{$s \stackrel{\$}{\leftarrow} \binset{n}$
    	%DIF >  \State $x_i^t \leftarrow \ma(f(x)|| s) \oplus \ma(f(x) || s+e^i)$
		}\State \DIFadd{%
\mbox{%DIFAUXCMD
$\begin{array}{l@{}l}
		x_i^t \leftarrow& \ma(f(x)|| s) \\
		& \oplus~ \ma(f(x) || (s\oplus e^i))
		\end{array}$
}%DIFAUXCMD
}\EndFor
	\State \DIFadd{$x'_i \gets $ the majority of $\{x_i^1, \cdots, x_i^T\}$
}\EndFor
\State \Return \DIFadd{$x'_1\cdots x'_n||R$
}\end{algorithmic}
\caption{\DIFadd{Simple Case $\mathcal{B}$}} \label{alg:simple-case}
\end{marginfigure}
\begin{align*}
\DIFadd{B(x,s) \oplus B(x, s\oplus e^i) =}& \DIFadd{\sum_j x_j s_j \oplus \sum_j x_j (s_j \oplus e^i_j)}\\
\DIFadd{=}& \DIFadd{\sum_{j \not= i} (x_j s_j \oplus x_j s_j) \oplus x_i s_i \oplus x_i (s_i \oplus 1)}\\
\DIFadd{=}& \DIFadd{~x_i
}\end{align*}
\DIFadd{The key technical challenge in proving that $\mathcal{B}$ inverts $g$ with non-negligible probability arises from the fact that the calls to $\ma$ made during one iteration of $\mathcal{B}$ are not independent.
In particular, all calls to $\ma$ share the same $x$ and the calls $\ma(f(x)|| s)$ and $\ma(f(x) || (s \oplus e^i))$ use correlated randomness as well.
}

\DIFadd{We solve the first issue by showing that there exists a large set of $x$ values for which $\ma$ still works with large probability.
The latter issue of lack of independence between $\ma(f(x)|| s)$ and $\ma(f(x) || (s \oplus e^i))$ can be solved using a union bound since the success probability of the adversary $\ma$ is high enough.
}

\DIFadd{Formally, define the set $G$ of ``good'' $x$'s, for which it is easy for $\ma$ to predict the right bit:
}$$\DIFadd{G := \left\{x \left| \Pr_r \left[ E \right]\geq \frac{3}{4} + \frac{\epsilon(n)}{2} \right. \right\}.}$$
\DIFadd{Now we prove that $G$ is not a small set. More formally, we claim that:
}$$\DIFadd{\Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[x \in G] \geq \frac{\epsilon(n)}{2}.}$$
\DIFadd{Assume that $\Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[x \in G] < \frac{\epsilon(n)}{2}$. Then we have the following contradiction:
}\begin{align*}
\DIFadd{\frac{3}{4} + \epsilon(n) \leq}&\DIFadd{~ \Pr_{x,r}[E]}\\
\DIFadd{=}&\DIFadd{~ \Pr_x }[\DIFadd{x \in G}] \DIFadd{\Pr_{r}[E| x\in G] + \Pr_x }[\DIFadd{x \notin G}] \DIFadd{\Pr_{r}[E | x\notin G]}\\
\DIFadd{< }&\DIFadd{~ \frac{\epsilon(n)}{2} \cdot 1 + 1\cdot \left(\frac{3}{4}+\frac{\epsilon(n)}{2}\right)  = \frac{3}{4} + \epsilon(n).
}\end{align*}
\DIFadd{Now consider a single iteration for a fixed $x \in G$:
}\begin{align*}
&\DIFadd{\Pr_{s} \left[ \ma(f(x), s) \oplus \ma(f(x), s\oplus e^i) = x_i \right]}\\
&\DIFadd{=~ \Pr_{s} \left[ \text{Both $\ma$'s are correct} \right] + \Pr_{s} \left[ \text{Both $\ma$'s are wrong} \right]}\\
&\DIFadd{\geq~ \Pr_{s} \left[ \text{Both $\ma$'s are correct} \right] = 1- \Pr_{s} \left[ \text{Either $\ma$ is wrong} \right]}\\
&\DIFadd{\geq~ 1- 2\cdot\Pr_{s} \left[ \text{$\ma$ is wrong} \right]}\\
&\DIFadd{\geq~ 1-2\left(\frac{1}{4} - \frac{\epsilon(n)}{2} \right) 
= \frac{1}{2} + \epsilon(n).
}\end{align*}
\DIFadd{Let $Y_i^t$ be the indicator random variable that $x_i^t = x_i$ (namely, $Y_i^t=1$ with probability $\Pr[x_i^t = x_i]$ and $Y_i^t=0$ otherwise).
Note that $Y_i^1, \cdots, Y_i^T$ are independent and identical random variables, and for all $t \in \{1,\ldots, T\}$, we have $\Pr[Y_i^t=1] = \Pr[x_i^t = x_i] \geq \frac{1}{2} + \epsilon(n)$.
Next we argue that majority of $x_i^t$ coincide with $x_i$ with high probability.
}\begin{align*}
\DIFadd{\Pr[x'_i \neq x_i]
=}&\DIFadd{~ \Pr\left[\sum_{t=1}^T Y_i^t \leq \frac{T}{2} \right]}\\
\DIFadd{=}&\DIFadd{~ \Pr\left[\sum_{t=1}^T  Y_i^t- \left(\frac{1}{2} + \epsilon(n) \right)T \leq \frac{T}{2} - \left(\frac{1}{2} + \epsilon(n) \right)T \right]}\\
\DIFadd{\leq}&\DIFadd{~ \Pr\left[ \left| \sum_{t=1}^T  Y_i^t- \left(\frac{1}{2} + \epsilon(n) \right)T \right| \geq \epsilon(n)T \right]}\\
& \DIFadd{\text{Let $X_1,\cdots,X_m$ be i.i.d. random variables taking values 0 or 1. Let $\Pr[X_i=1] = p$.}}\\
& \DIFadd{\text{By Chebyshev's Inequality, $\Pr\left[ \left| \sum X_i - pm \right| \geq \delta m \right] \leq \frac{1}{4\delta^2 m}$.}}\\
\DIFadd{\leq}&\DIFadd{~ \frac{1}{4\epsilon(n)^2T} = \frac{1}{2n}.
}\end{align*}
\DIFadd{Then, completing the argument, we have
}\begin{align*}
&\DIFadd{\Pr_{x,r}[\mathcal{B}(1^{2n}, g(x,r)) = (x,r)]}\\
&\DIFadd{\geq~ \Pr_x }[\DIFadd{x \in G}] \DIFadd{\Pr[x'_1 = x_1, \cdots x'_n = x_n | x \in G]}\\
&\DIFadd{\geq~ \frac{\epsilon(n)}{2} \cdot \left(1- \sum_{i=1}^n\Pr[x'_i \neq x_i | x \in G]\right)}\\
&\DIFadd{\geq~ \frac{\epsilon(n)}{2} \cdot \left(1- n \cdot\frac{1}{2n} \right) =  \frac{\epsilon(n)}{4}.
}\end{align*}



\bigskip
\noindent\textbf{\underline{\DIFadd{Real Case.}}} \DIFadd{Now, we describe the final case where $\Pr_{x,r}[E] \geq \frac{1}{2} + \epsilon(n)$ and $\epsilon(\cdot)$ is a non-negligible function.
The key technical challenge in this case is that we cannot make two related calls to $\ma$ as was done in the simple case above since we can't argue that both calls to $\ma$ will be correct with high enough probability.
However, just using one call to $\ma$ seems insufficient.
The key idea is to just guess one of those values.
Very surprisingly, this idea along with careful analysis magically works out.
Just like the previous two cases, we start by describing the algorithm $\mathcal{B}$ in Figure~\ref{alg:real-case}.
}


\begin{marginfigure}
\begin{algorithmic}
\State \DIFadd{$T = \frac{2n}{\epsilon(n)^2}$
	}\For {\DIFadd{$\ell = 1$ }\textbf{\DIFadd{to}} \DIFadd{$\log T$}}
		\State \DIFadd{$s_\ell \stackrel{\$}{\leftarrow} \binset{n}$
		}\State \DIFadd{$b_\ell \stackrel{\$}{\leftarrow} \{0,1\}$
	}\EndFor
\For {\DIFadd{$i = 1$ }\textbf{\DIFadd{to}} \DIFadd{$n$}}
	\ForAll {\DIFadd{$L \subseteq \{1,2,\cdots, \log T\}$}}
		\State \DIFadd{$S_L :=\bigoplus_{j \in L} s_j$
		}\State \DIFadd{$B_L := \bigoplus_{j \in L} b_j$
		}\State \DIFadd{$x_i^L \leftarrow B_L \oplus \ma(f(x) || S_L\oplus e^i)$
	}\EndFor
	\State \DIFadd{$x'_i \gets $ majority of $\{x_i^\emptyset, \cdots, x_i^{[\log T]}\}$
}\EndFor
\State \Return \DIFadd{$x'_1\cdots x'_n||R$
}\end{algorithmic}
\caption{\DIFadd{Real Case $\mathcal{B}$}} \label{alg:real-case}
\end{marginfigure}

\medskip
\DIFadd{In the beginning of the algorithm, $\mathcal{B}$ samples $\log T$ random strings $\{ s_\ell \}_{\ell}$ and bits $\{ b_\ell \}_{\ell}$.
Since there are only $\log T$ values, with probability $\frac{1}{T}$ (which is polynomial in $n$) all the $b_{\ell}$'s are correct, i.e., $b_\ell = B(x, s_\ell)$. In the rest of this proof, we denote this event as $F$.
Now note that if $F$ happens, then $B_L$ as defined in the algorithm is also equal to $B(x, S_L)$ (we denote the $k^{\text{th}}$-bit of $s$ with $(s)_k$): 
}

\begin{align*}
\DIFadd{B(x,S_L) }&\DIFadd{= \sum_{k=1}^n x_k (\bigoplus_{j \in L} s_j)_k }\\ 
         &\DIFadd{=  \sum_{k=1}^n x_k \sum_{j \in L} \left(s_j\right)_k }\\
         &\DIFadd{= \sum_{j \in L} \sum_{k=1}^n x_k (s_j)_k }\\
         &\DIFadd{= \sum_{j \in L} B(x,s_j) }\\
         &\DIFadd{= \sum_{j\in L} b_j  }\\
         &\DIFadd{= B_L
}\end{align*}

\DIFadd{Thus, with probability $\frac{1}{T}$, we have all the right guesses for one of the invocations, and we just need to bound the probability that $\ma(f(x) || S_L \oplus e^i) = B(x, S_L \oplus e^i)$.
However there is a subtle issue. Now the events $Y_i^\emptyset, \cdots, Y_i^{[\log T]}$ are no longer independent.
Nevertheless, we can still show that they are pairwise independent, and the Chebyshev's Inequality still holds. Now we give the formal proof.
}

\DIFadd{Just as in the simple case, we define the set $G$ as
}$$\DIFadd{G := \left\{x \left| \Pr_r \left[ E \right]\geq \frac{1}{2} + \frac{\epsilon(n)}{2} \right. \right\},}$$
\DIFadd{and with an identical argument we obtain that:
}

$$\DIFadd{\Pr_{x \stackrel{\$}{\leftarrow} \binset{n}}[x \in G] \geq \frac{\epsilon(n)}{2}}$$


\marginnote[-2cm]{%
\noindent\textbf{Pairwise Independence and Chebyshev's Inequality.} For the sake of completeness, we prove the Chebyshev's Inequality here.
\begin{definition}[Pairwise Independence]
A collection of random variables $\{X_1,\cdots,X_m\}$ is said to be \emph{pairwise independent} if for every pair of random variables $(X_i, X_j), i \neq j$  and every pair of values $(v_i,v_j)$, it holds that
\[\Pr[X_i = v_i, X_j = v_j] = \Pr[X_i = v_i]\Pr[X_j = v_j]\]
\end{definition}

\begin{theorem}[Chebyshev's Inequality]\label{thm:Chebyshev}
Let $X_1,\hdots,X_m$ be pairwise independent and identically distributed binary random variables. In particular, for every $i \in [m]$, $\Pr[X_i = 1] = p$ for some $p\in [0,1]$ and $\Pr[X_i=0]=1-p$. Then it holds that
$$\Pr\left[\left|\sum_{i=1}^m X_i - pm\right| \geq \delta m\right] \leq \frac{1}{4\delta^2m}.$$
\end{theorem}

\proof
Let $Y = \sum_i X_i$. Then
\begin{align*}
&\Pr\left[\left|\sum_{i=1}^m X_i - pm\right| > \delta m\right] \\
&=~ \Pr\left[\left(\sum_{i=1}^m X_i - pm\right)^2> \delta^2 m^2\right]\\
&\leq~ \frac{\mathbb{E}\left[\left|Y - pm\right|^2\right]}{\delta^2m^2} = \frac{\text{Var}(Y)}{\delta^2m^2} \\
\end{align*}
Observe that
\begin{align*}
\text{Var}(Y) &= \mathbb{E}\left[Y^2\right] - \left(\mathbb{E}[Y]\right)^2\\
&= \sum_{i=1}^m \sum_{j=1}^m \left( \mathbb{E}\left[X_iX_j\right] - \mathbb{E}\left[X_i\right] \mathbb{E}\left[X_j\right]\right)\\
& \text{By pairwise independence, for $i \neq j$,} \\  
& \text{$\mathbb{E}\left[X_i X_j\right] = \mathbb{E}\left[X_i\right] \mathbb{E}\left[X_j\right]$.}\\
&= \sum_{i=1}^m \mathbb{E}\left[X_i^2\right] - \mathbb{E}\left[X_i\right]^2\\
&= mp(1-p).
\end{align*}
Hence
$$\Pr\left[\left|\sum_{i=1}^m X_i - pm\right| \geq\delta m\right] \leq \frac{mp(1-p)}{\delta^2m^2} \leq \frac{1}{\delta^2m}.$$
\qed
}

%DIF >  Correctness of $\mathcal{B}$ follows from the fact in case $b_\ell = B(x,s_\ell)$ for every $\ell \in [\log T]$ then $\forall L \subseteq [\log T]$, it holds that
\DIFadd{Next, given $\{ b_\ell = B(x,s_\ell) \}_{\ell \in [\log T]}$ and $x\in G$, we have:
}\begin{align*}
&\DIFadd{\Pr_{r} \left[  B_L \oplus \ma(f(x) || S_L \oplus e^i) = x_i \right] }\\
&\DIFadd{=~ \Pr_{r} \left[ B(x,S_L) \oplus \ma(f(x) || S_L \oplus e^i) = x_i \right]}\\
&\DIFadd{=~ \Pr_{r} \left[ \ma(f(x) || S_L \oplus e^i) =  B(x,S_L \oplus e^i) \right]}\\
&\DIFadd{\geq~ \frac{1}{2} + \frac{\epsilon(n)}{2}
}\end{align*}
\DIFadd{For the same $\{ b_\ell \}_\ell$ and $x\in G$, let $Y_i^L$ be the indicator random variable that $x_i^L = x_i$.
Notice that $Y_i^\emptyset, \cdots, Y_i^{[\log T]}$ are pairwise independent and $\Pr[Y_i^L=1] = \Pr[x_i^L = x_i] \geq \frac{1}{2} + \frac{\epsilon(n)}{2}$.
}\begin{align*}
\DIFadd{\Pr[x'_i \neq x_i] =}& \DIFadd{\Pr\left[\sum_{L \subseteq [\log T]} Y_i^L \leq \frac{T}{2} \right]}\\
\DIFadd{=}& \DIFadd{\Pr\left[\sum_{L \subseteq [\log T]} Y_i^L - \left(\frac{1}{2} +  \frac{\epsilon(n)}{2} \right)T \leq \frac{T}{2} - \left(\frac{1}{2} +  \frac{\epsilon(n)}{2} \right)T \right]}\\
\DIFadd{\leq}& \DIFadd{\Pr\left[ \left| \sum_{L \subseteq [\log T]} Y_i^L - \left(\frac{1}{2} +  \frac{\epsilon(n)}{2} \right)T \right| \geq \frac{\epsilon(n)}{2} T \right]}\\
& \DIFadd{\text{(By Theorem~\ref{thm:Chebyshev})}}\\
\DIFadd{\leq}& \DIFadd{\frac{1}{4\left( \frac{\epsilon(n)}{2}\right)^2T} = \frac{1}{2n}.
}\end{align*}
\DIFadd{Completing the proof, we have that:
}\begin{align*}
& \DIFadd{\Pr_{x,r}[\mathcal{B}(1^{2n}, g(x,r)) = (x,r)]}\\
&\DIFadd{\geq~  \Pr_{\{ b_\ell, s_\ell \}_\ell}\left[ F \right] \cdot  \Pr_x }[\DIFadd{x \in G}] \DIFadd{\cdot \Pr[x'_1 = x_1, \cdots x'_n = x_n ~|~ x \in G ~\wedge~ F]}\\
&\DIFadd{\geq~ \frac{1}{T} \cdot \frac{\epsilon(n)}{2} \cdot \left(1- \sum_{i=1}^n\Pr[x'_i \neq x_i ~|~  x \in G ~\wedge~ F]\right)}\\
&\DIFadd{\geq~ \frac{\epsilon(n)^2}{2n} \cdot \frac{\epsilon(n)}{2} \cdot \left(1- n \cdot\frac{1}{2n} \right) =  \frac{\epsilon(n)^3}{8n}
}\end{align*}
\qed



\newpage
\section*{\DIFadd{Exercises}}
\begin{exercise}
\label{ex:product} \DIFadd{If $\mu(\cdot)$ and $\nu(\cdot)$ are negligible functions then show that $\mu(\cdot) \cdot \nu(\cdot)$ is a negligible function.
}\end{exercise}

\begin{exercise}
\label{ex:product} \DIFadd{If $\mu(\cdot)$ is a negligible function and $f(\cdot)$ is a function polynomial in its input then show that $\mu(f(\cdot))$}\footnote{\DIFadd{Assume that $\mu$ and $f$ are such that $\mu(f(\cdot))$ takes inputs from $\mathbb{Z}^+$ and outputs values in $[0,1]$.}} \DIFadd{are negligible functions.
}\end{exercise}

\begin{exercise}\label{ex:PNP} \DIFadd{Prove that the existence of one-way functions implies $P \neq NP$.
}\end{exercise}

\begin{exercise}
\DIFadd{Prove that there is no one-way function $f:\{0,1\}^n\to \{0,1\}^{\lfloor \log_2 n\rfloor}$.
}\end{exercise}


\begin{exercise} \DIFadd{Let $f:\{0,1\}^n\to \{0,1\}^{n}$ be any one-way function then is $f'(x) \stackrel{def}{=} f(x)\oplus x$ necessarily one-way?
}\end{exercise}

\begin{exercise}
\DIFadd{Prove or disprove: If $f: \{0,1\}^n\rightarrow \{0,1\}^n$ is a one-way function, then $g: \{0,1\}^n\rightarrow \{0,1\}^{n-\log n}$ is a one-way function, where $g(x)$ outputs the $n-\log n$ higher order bits of $f(x)$.
}\end{exercise}

\begin{exercise}
\DIFadd{Explain why the proof of Theorem~\ref{theorem:weakstrongOWF} fails if the attacker $\mathcal{A}$ in Figure~\ref{fig:adv:weak} sets $i = 1$ and not $i \stackrel{\$}{\leftarrow} \{1, 2, \cdots, q\}$.
}\end{exercise}

\begin{exercise}
\DIFadd{Given a (strong) one-way function construct a weak one-way function that is not a (strong) one-way function.
}\end{exercise}

\begin{exercise}
 \DIFadd{Let $f:\{0,1\}^n\to \{0,1\}^{n}$ be a weak one-way permutation (a weak one way function that is a bijection). More formally, $f$ is a PPT computable one-to-one function such that $\exists$ a constant $c >0$ such that $\forall$ non-uniform PPT machine $A$ and $\forall$ sufficiently large $n$ we have that:
    }\[\DIFadd{\Pr_{x,A}[A(f(x)) \not\in f^{-1}(f(x))] > \frac{1}{n^c}}\]

     \DIFadd{Show that $g(x) = f^T(x)$ is not a strong one way permutation. Here $f^T$ denotes the $T$ times self composition of $f$ and $T$ is a polynomial in $n$.
}

     \DIFadd{Interesting follow up reading if interested: With some tweaks the function above can be made a strong one-way permutation using explicit constructions of expander graphs. See Section 2.6 in }\url{http://www.wisdom.weizmann.ac.il/~oded/PSBookFrag/part2N.ps}
\end{exercise}




%DIF > \subsection{Proof: Fixing a Value in a One-way Function}
\DIFaddend %
%DIF < 	\item $Eval (C)$ output a circuit $C'$ such that $C'(e)$ is an encryption of $C(x)$ if $e$ was an encryption of $x$ and we have that $|e|\leq poly(|m|,k)$.
%DIF < 	\item How can I improve communication complexity of secure computation and NIZK?	
%DIF < 	\item Some more definitions
%DIF > \begin{theorem}
%DIF > Given a one-way function $f : \binset{n} \rightarrow \binset{m}$ and constants $x_0 \in \binset{n}$, $y_0 \in \binset{m}$, $\exists g : \binset{n} \rightarrow \binset{m}$ such that $g(x_0) = y_0$ where $g$ is a one-way function.\\
%DIF > \end{theorem}
%DIF > 
%DIF > Main Idea:  Set $g$ to be $f$, except at $x_0$, where $g(x_0) = y_0$.  If there exists an adversary that can break $g$, then that adversary will also break $f$, because the adversary can only know negligibly more information about $g$ than $f$.\\
%DIF > 
%DIF > \proof  Define the function $g$ as follows:
%DIF > 
%DIF > $g(x) = \left\{
%DIF > \begin{array}{lr}
%DIF >   y_0 & : x = x_0 \\
%DIF >   f(x) & : x \neq x_0
%DIF > \end{array}
%DIF > \right.$
%DIF > 
%DIF > Suppose there is an adversary $A$ that can break $g$ with non-negligible probability $\mu(n)$.\\
%DIF > 
%DIF > So, we have $\mu(n) = \underset{x \overset{\$}{\leftarrow} \binset{n}}{Pr} [ A(g(x)) \in g^{-1}(g(x)) ] = \sum\limits_{x \in \binset{n}} Pr(X = x) Pr [ A(g(x)) \in g^{-1}(g(x)) ]$\\
%DIF > 
%DIF > Since $x$ is uniformly distributed, $Pr[X = x] = \frac{1}{2^n}$.  We can split it into the cases $x : g(x) = y_0$ and $x : g(x) \neq y_0$:\\
%DIF > 
%DIF > $\mu(n) = \big[ \frac{1}{2^n} \sum\limits_{x \in \binset{n}, g(x) = y_0} Pr [ A(y_0) \in g^{-1}(y_0)) ] \big] + \big[ \frac{1}{2^n} \sum\limits_{x \in \binset{n}, g(x) \neq y_0} Pr [ A(g(x)) \in g^{-1}(g(x)) ] \big]$.\\
%DIF > 
%DIF > Let $p = | \{ x : g(x) = y_0 \} |$.  Consider the adversary $M$ where $M(y) = x_1$ for any $y$, where $x_1$ is a value of $x$ where $f(x_1) = y_0$.  Thus, $M$ breaks $f$ for any input where $f(x) = y_0$, of which there are $p - 1$ or $p$ (depending on whether $f(x_0) = y_0$).  So, the probability with which $M$ breaks $f$ is $\frac{p-1}{2^n}$ or $\frac{p}{2^n}$.  Either way, since $f$ is a one-way function, this implies that $\frac{p}{2^n}$ is a negligible function.\\
%DIF > 
%DIF > Now, since $Pr [ A(y_0) \in g^{-1}(g(x_0)) ] \leq 1$, we have:\\
%DIF > 
%DIF > $\mu(n) \leq \frac{p}{2^n} + \sum\limits_{x \in \binset{n}, g(x) \neq y_0} Pr [ A(g(x)) \in g^{-1}(g(x)) ]$\\
%DIF > 
%DIF > Notice that for any $x$ such that $g(x) \neq y_0$, we have $f(x) = g(x)$ and $f^{-1}(f(x)) = g^{-1}(g(x))$.\\
%DIF > 
%DIF > So $\mu(n) \leq \frac{p}{2^n} + \frac{1}{2^n}\sum\limits_{x \in \binset{n}, g(x) \neq y_0} Pr [ A(f(x)) \in f^{-1}(f(x)) ]$\\
%DIF > 
%DIF > Thus, if we consider $A$ as an adversary for $f$, then we get:\\
%DIF > 
%DIF > $\underset{x \overset{\$}{\leftarrow} \binset{n}}{Pr} [ A(f(x)) \in f^{-1}(f(x)) ] \; \geq \; \frac{1}{2^n}\sum\limits_{x \in \binset{n}, g(x) \neq y_0} Pr [ A(f(x)) \in f^{-1}(f(x)) ] \; \geq \; \mu(n) - \frac{p}{2^n}$\\
%DIF > 
%DIF > $\mu(n)$ is non-negligible and $\frac{p}{2^n}$ is negligible, and so, $\mu(n) - \frac{p}{2^n}$ is non-negligible.  Thus $A$ is an adversary that breaks $f$ with non-negligible probability.  \qed
%DIF > 
\DIFaddbegin 

\chapter{\DIFadd{Pseudorandomness}}
\DIFadd{In this chapter, our objective is to transform a small amount of entropy into a distribution that closely resembles randomness.
The idea is to start with a small amount of entropy, known as the ``seed", and use a deterministic process to generate a new distribution that appears ``indistinguishable" from random. 
However, before we dive into the specifics of how to achieve this, we need to clarify what we mean by ``indistinguishable."
}

\section{\DIFadd{Statistical Indistinguishability}}
\DIFadd{The first definition of indistinguishability we will focus on is that of statistical indistinguishability.
It turns out that defining what it means for two distributions to be indistinguishable by an adversary is tricky.
In particular, it is tricky to define indistinguishability for a single pair of distributions because the length of the output of a random variable is a constant.
Therefore, in order for our definition to make sense, we will work with collections of distributions, called }\emph{\DIFadd{ensembles}}
\begin{definition}[Ensemble of Probability Distributions]
\DIFadd{An }\emph{\DIFadd{ensemble}} \DIFadd{of probability distributions is a sequence of random variables $\{X_n\}_{n\in \mathbb{N}}$. 
}\end{definition}
\DIFadd{In this definition, $n$ is a parameter.
Sometimes, we write $\{X_n\}_n$ or even simply $X_n$, when it is clear from context that we are talking about an ensemble.
}

\begin{definition}[Statistical Indistinguishability]
    \DIFadd{Two ensembles of probability distributions $\{X_n\}_n$ and $\{Y_n\}_n$ are said to be }\emph{\DIFadd{statistically indistinguishable}} \DIFadd{if for all adversaries $\ma$, the quantities
    }$$\DIFadd{p(n) := \Pr[\ma(X_n) = 1] = \sum_x \Pr[X_n = x]\Pr[\ma(1^n,x) = 1]}$$
    \DIFadd{and
    }$$\DIFadd{q(n) := \Pr[\ma(Y_n) = 1] = \sum_y \Pr[Y_n = y]\Pr[\ma(1^n,y) = 1]}$$
    \DIFadd{differ by a negligible amount.
    In particular, the ensembles are said to be statistically indistinguishable if
    }$$\DIFadd{\Delta_\ma(n) = |p(n) - q(n)| = |\Pr[\ma(X_n) = 1] - \Pr[\ma(Y_n) = 1]|}$$
    \DIFadd{is negligible in $n$.
This equivalence is denoted by
}$$\DIFadd{\{X_n\}_n \approx_S \{Y_n\}_n}$$
\end{definition}
\DIFadd{Note that our attacker in this scenario is not computationally bounded, as is usual}\footnote{\DIFadd{Statistical indistinguishability is a very strong requirement, and it makes use of a very powerful adversary, so it will serve mostly as an illustrative example.}}\DIFadd{.
We also do not require the ensemble to be efficiently samplable.
}

\DIFadd{This definition is closely related to the concept of the }\textit{\DIFadd{statistical distance}} \DIFadd{between two probability distributions.
}\begin{definition}[Statistical Distance]
\DIFadd{The }\emph{\DIFadd{statistical distance}} \DIFadd{between two distributions $X$ and $Y$ is defined as
}$$\DIFadd{SD(X, Y) = \frac{1}{2}\sum\limits_{v \in S}|\Pr[X_n = v] - \Pr[Y_n = v]|}$$
\DIFadd{where $S = Support(X_n) \cup Support(Y_n)$.
}\end{definition}
\DIFadd{In fact, we can show that $\Delta_{\ma}(n) \le SD(X_n, Y_n)$.
}\begin{lemma}[Relationship between $SD$ and $\Delta_\ma$]
    \DIFadd{For any adversary $\ma$,
    }$$\DIFadd{\Delta_{\ma}(n) \le SD(X_n, Y_n)}$$
\end{lemma}

\proof
\DIFadd{Let $\Omega$ be the sample space for $X_n$ and $Y_n$.
}

\DIFadd{Let $T = \{v \in \Omega | \Pr[v \leftarrow X_n] > \Pr[v \leftarrow Y_n]\}$.
}

\DIFadd{First, we will prove that $SD(X_n, Y_n) = \sum\limits_{v \in \Omega} |\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]|$.
}

\begin{align*}
    \DIFadd{\sum\limits_{v \in \Omega} \Pr[v \leftarrow X_n] }&\DIFadd{= \sum\limits_{v \in \Omega} \Pr[v \leftarrow Y_n] = 1 }\\
    \DIFadd{\sum\limits_{v \in T}\Pr[v \leftarrow X_n] + \sum\limits_{v \in \Omega\setminus T}\Pr[v \leftarrow X_n] }&\DIFadd{= \sum\limits_{v \in T}\Pr[v \leftarrow Y_n] + \sum\limits_{v \in \Omega\setminus T}\Pr[v \leftarrow Y_n]}\\
    \DIFadd{\sum\limits_{v \in T}(\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]) }&\DIFadd{= \sum\limits_{v \in \Omega \setminus T}(\Pr[v \leftarrow Y_n] - \Pr[v \leftarrow X_n])}\\
    \DIFadd{\sum\limits_{v \in T}|\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]| }&\DIFadd{= \sum\limits_{v \in \Omega \setminus T}|\Pr[v \leftarrow Y_n] - \Pr[v \leftarrow X_n]|}\\
    \DIFadd{\sum\limits_{v \in T}|\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]| }&\DIFadd{= \sum\limits_{v \in \Omega \setminus T}|\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]|}\\
    \DIFadd{\sum\limits_{v \in \Omega}|\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]| }&\DIFadd{= \sum\limits_{v \in T}|\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]|}\\
    &\DIFadd{\;\;\;\; + \sum\limits_{v \in \Omega \setminus T}|\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]|}\\
    \DIFadd{2SD(X_n, Y_n) }&\DIFadd{= 2 \cdot \sum\limits_{v \in T}|\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]|}\\
    \DIFadd{SD(X_n, Y_n) }&\DIFadd{= \sum\limits_{v \in T}|\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]|
}\end{align*}

\DIFadd{Now we will show the main result of the lemma.
}\begin{align*}
    \DIFadd{\Delta_\ma(n) }&\DIFadd{= |\Pr[\ma(X_n) = 1] - \Pr[\ma(Y_n) = 1]| }\\
    &\DIFadd{= |\sum\limits_{v \in \Omega} (\Pr[\ma(v) = 1] \cdot \Pr[v \leftarrow X_n]) - (\Pr[\ma(v) = 1] \cdot \Pr[v \leftarrow Y_n])|}\\
    &\DIFadd{= |\sum\limits_{v \in \Omega} \Pr[\ma(v) = 1] \cdot ( \Pr[v \leftarrow X_n]) - \Pr[v \leftarrow Y_n])| }\\
    &\DIFadd{= |\sum\limits_{v \in T} \Pr[\ma(v) = 1] \cdot ( \Pr[v \leftarrow X_n]) - \Pr[v \leftarrow Y_n]) }\\
    &\DIFadd{\;\;\;\; + \sum\limits_{v \in \Omega \setminus T} \Pr[\ma(v) = 1] \cdot ( \Pr[v \leftarrow X_n]) - \Pr[v \leftarrow Y_n])| }\\
    &\DIFadd{= \sum\limits_{v \in T} \Pr[\ma(v) = 1] \cdot ( \Pr[v \leftarrow X_n]) - \Pr[v \leftarrow Y_n]) }\\
    &\DIFadd{\;\;\;\; + \sum\limits_{v \in \Omega \setminus T} \Pr[\ma(v) = 1] \cdot ( \Pr[v \leftarrow X_n]) - \Pr[v \leftarrow Y_n]) }\\
    &\DIFadd{= \sum\limits_{v \in T} \Pr[\ma(v) = 1] \cdot |\Pr[v \leftarrow X_n]) - \Pr[v \leftarrow Y_n]| }\\
    &\DIFadd{\;\;\;\; + \sum\limits_{v \in \Omega \setminus T} \Pr[\ma(v) = 1] \cdot |\Pr[v \leftarrow X_n]) - \Pr[v \leftarrow Y_n]| }\\
    &\DIFadd{\le \sum\limits_{v \in T} |\Pr[v \leftarrow X_n] - \Pr[v \leftarrow Y_n]|}\\
    &\DIFadd{= SD(X_n, Y_n)
}\end{align*}
\qed

\section{\DIFadd{Computational Indistinguishability}}
\DIFadd{We now turn to a more reasonable definition of indistinguishability.
In particular, this definition imposes the usual computational limits on the adversary $\ma$. 
It also requires that the ensembles of distributions in question be efficiently samplable.
Besides those changes, however, the definition of }\emph{\DIFadd{computational indistinguishability}} \DIFadd{is quite similar to that of }\emph{\DIFadd{statistical indistinguishability}}\DIFadd{.
}

\begin{definition}[Computational Indistinguishability]
\DIFadd{Two ensembles of probability distributions $\{X_n\}_n$ and $\{Y_n\}_n$ (which are }\emph{\DIFadd{samplable}} \DIFadd{in time polynomial in $n$) are said to be }\emph{\DIFadd{computationally indistinguishable}} \DIFadd{if for all (non-uniform) PPT adversaries $\ma$, the quantities
}$$\DIFadd{p(n) := \Pr[\ma(1^n, X_n) = 1] = \sum_x \Pr[X_n = x]\Pr[\ma(1^n,x) = 1]}$$
\DIFadd{and
}$$\DIFadd{q(n) := \Pr[\ma(1^n,Y_n) = 1] = \sum_y \Pr[Y_n = y]\Pr[\ma(1^n,y) = 1]}$$
\DIFadd{differ by a negligible amount; i.e. $|p(n) - q(n)|$ is negligible in $n$.    
This equivalence is denoted by
}$$\DIFadd{\{X_n\}_n\approx_C \{Y_n\}_n}$$
\DIFadd{However, since this is the main form of indistinguishability that we are concerned with, we will simply write
}$$\DIFadd{\{X_n\}_n\approx \{Y_n\}_n}$$
\end{definition}
\DIFadd{We now prove some properties of computationally indistinguishable ensembles that will be useful later on.
}

\begin{lemma}[Sunglass Lemma]
\DIFadd{If $\{X_n\}_n\approx\{Y_n\}_n$ and $P$ is a PPT machine, then
}

$$\DIFadd{\{P(X_n)\}_n\approx \{P(Y_n)\}_n}$$
\end{lemma}

\proof
\DIFadd{Consider an adversary $\ma$ that can distinguish $\{P(X_n)\}_n$ from $\{P(Y_n)\}_n$ with non-negligible probability. Then the adversary $\ma\circ P$ can distinguish $\{X_n\}_n$ from $\{Y_n\}_n$ with the same non-negligible probability. Since $P$ and $\ma$ are both PPT machines, the composition is also a PPT machine. This proves the contrapositive of the lemma.
}\qed

\DIFadd{The name of the lemma comes from the idea that if two objects are indistinguishable without putting on sunglasses, then they should remain indistinguishable after putting on sunglasses.
}

\begin{lemma}[Multicopy Lemma]
\DIFadd{For a polynomial $t:\mathbb{Z}^+\rightarrow\mathbb{Z}^+$ let the $t$-product of $\{Z_n\}_n$ be
}

$$\DIFadd{\{Z_n^{(1)}, Z_n^{(2)},\hdots, Z_n^{(t(n))}\}_n}$$
\DIFadd{where the $Z_n^{(i)}$s are independent copies of $Z_n$. If
}$$\DIFadd{\{X_n\}_n\approx\{Y_n\}_n}$$
\DIFadd{then
}$$\DIFadd{\{X_n^{(1)},\hdots,X_n^{(t)}\}_n\approx\{Y_n^{(1)},\hdots,Y_n^{(t)}\}_n}$$
\DIFadd{as well.
}\end{lemma}
\DIFadd{Intuitively, if you can't tell apart a red ball and a blue ball, then you can't tell apart multiple copies of the red and blue balls.
}

\begin{proof}
\DIFadd{We proceed by what is known as a hybrid argument.
Consider the set of tuple random variables
}$$\DIFadd{H^{(i,t)}_n = (Y_n^{(1)},\hdots,Y_n^{(i)},X_n^{(i+1)},X_n^{(i+2)},\hdots,X_n^{(t)})}$$
\DIFadd{for integers $0\le i\le t$. 
For instance, when $i=0$:
}$$\DIFadd{H^{(0,t)}_n = (X_n^{(1)},X_n^{(2)},\hdots,X_n^{(t)}) = \overline{X}_n}$$
\DIFadd{Similarly, when $i=t$:
}$$\DIFadd{H^{(t,t)}_n = (Y_n^{(1)},Y_n^{(2)},\hdots,Y_n^{(t)}) = \overline{Y}_n}$$

\DIFadd{Assume, for the sake of contradiction, that there is a PPT adversary $\ma$ that can distinguish between $\{H^{(0,t)}_n\}_n$ and $\{H^{(t,t)}_n\}_n$ with non-negligible probability difference $\varepsilon(n)$. Suppose that $\ma$ returns 1 with probability $P_i$ when it runs on samples from $H^{(i,t)}_n$. 
That is, $P_i = \Pr[\ma(H^{(i,t)}_n = 1)]$
By definition, $|P_0 - P_t|\ge \varepsilon(n)$. 
}

\DIFadd{Using the common add-one-subtract-one trick, we can find that
}\begin{align*}
\DIFadd{|P_0 - P_t| }&\DIFadd{= |P_0 - P_{1} + P_{1} - P_{2} + ... + P_{t-1} - P_{t}| }\\
&\DIFadd{= |(P_0 - P_{1}) + (P_{1} - P_{2}) + ... + (P_{t-1} - P_{t})| }\\
&\DIFadd{\leq  |P_0 - P_{1}| + |P_{1} - P_{2}| + ... + |P_{t-1} - P_{t}|
}\end{align*}
\DIFadd{Since $|P_0 - P_t| \ge \varepsilon(n)$, it follows that $|P_0 - P_{1}| + |P_{1} - P_{2}| + ... + |P_{t-1} - P_{t}| \ge \varepsilon(n)$.
Then there must exist some index $k$ for which
}\begin{align*}
\DIFadd{|P_k - P_{k+1}| }&\DIFadd{\geq \frac{\varepsilon(n)}{t}
}\end{align*}
\DIFadd{Note that $\frac{\varepsilon(n)}{t}$ is non-negligible because $t$ is polynomial.
This implies that $\{H^{(k,t)}_n\}_n$ and $\{H^{(k+1,t)}_n\}_n$ are distinguishable.
}

\DIFadd{Using this information, we can construct an adversary $\mb$ that can distinguish $X_n$ from $Y_n$.
Given an input $Z_n$, which is either $X_n$ or $Y_n$, $\mb$ works as follows:
}$$\DIFadd{\mb(Z_n) = \ma(X_1, ..., X_{k-1}, Z, Y_{k+1}, ..., Y_t)}$$
\DIFadd{By the argument above, for some value}\footnote{\DIFadd{$\mb$ is non-uniform, so it can ``know" which value of $k$ it should use.}} \DIFadd{of $k$, this computation gives $|\Pr[\mb(X_n)=1] - \Pr[\mb(Y_n) = 1]| \ge \frac{\varepsilon(n)}{t}$.
}


%DIF > However, using the Sunglass Lemma, note that the computational indistinguishability of $X_n$ and $Y_n$ implies that $\{H^{(k,t)}_n\}_n$ and $\{H^{(k+1,t)}_n\}_n$ are computationally indistinguishable. 
\DIFadd{This is a contradiction. 
}\qed

\DIFadd{Intuitively, the idea behind proofs by hybrid argument is to create a chain of polynomially many hybrids such that the hybrids are pairwise indistinguishable at each step.
Visually:
}$$\DIFadd{H^{(0,t)}_n \approx H^{(1,t)}_n \approx H^{(2,t)}_n \approx ... \approx H^{(t-1,t)}_n \approx H^{(t,t)}_n}$$
\DIFadd{This implies that 
}$$\DIFadd{H^{(0,t)}_n \approx H^{(t,t)}_n}$$
\DIFadd{which is the same thing as saying that
}$$\DIFadd{\overline{X}_n \approx \overline{Y}_n}$$


%DIF > This is equivalent to trying to distinguish the ensembles $\{(X_n,T_n)\}_n$ from $\{(Y_n,T_n)\}_n$, where $T_n$ is independent of $X_n$ and $Y_n$ ($T_n$ is the random variable representing all coordinates but the $k$-th coordinate). Note that
%DIF > 
%DIF > \begin{align*}
%DIF > r(n)/t&\le |Pr[A(Y_n,T_n) = 1] - Pr[A(X_n,T_n) = 1]|\\
%DIF > &= |\sum_{x,t} (Pr[Y_n = x,T_n = t] - Pr[X_n = x,T_n = t])Pr[A(x,t) = 1]|\\
%DIF > &= |\sum_t Pr[T_n = t]\sum_x (Pr[Y_n = x] - Pr[X_n = x])Pr[A(x,t) = 1]|\\
%DIF > &\le \sum_t Pr[T_n = t]\sum_x |Pr[Y_n = x] - Pr[X_n = x]|Pr[A(x,t) = 1]\\
%DIF > \end{align*}
%DIF > 
%DIF > so by the probabilistic method there is a $t_0$ for which $r(n)/t\le \sum_x |Pr[Y_n = x] - Pr[X_n = x]|Pr[A(x,t_0) = 1]$. This means that $X_n$ can be distinguished from $Y_n$ with probability difference $r(n)/t$, which is non-negligible (a contradiction).
\end{proof}


\iffalse
\section{\DIFadd{Hard Concentrate Bit}}
\DIFadd{We start by asking the following question: Is it possible to concentrate the strength of a one-way function into one bit? In particular, given a one-way function $f$, does there exist one bit that can be computed efficiently from the input $x$, but is hard to compute given $f(x)$?
}\begin{definition}[Hard Concentrate Bit]
\DIFadd{Let $f:\binset{n} \rightarrow \binset{n}$ be a one-way function.
$B:\{0,1\}^n \rightarrow \{0,1\}$ is a hard concentrate bit of $f$ if:
}\begin{itemize}
\item[\DIFadd{-}] \DIFadd{$B$ is computable by a PPT machine, and
}\item[\DIFadd{-}] \DIFadd{$\forall$ non-uniform PPT adversaries $\mathcal{A}$ we have that
	}$$\DIFadd{\Pr_{x\stackrel{\$}{\leftarrow} \binset{n}}[\mathcal{A}(1^n, f(x)) = B(x)] \leq \frac{1}{2} + \mathsf{negl}(n).}$$
\end{itemize}
\end{definition}

\noindent\textbf{\DIFadd{A simple example.}}
\DIFadd{Let $f$ be a one-way function. Consider the one-way function $g(b, x) = 0 || f(x)$ and a hard concentrate bit $B(b, x) = b$.
Intuitively, the value $g(b, x)$ does not reveal any information about the first bit $b$, thus no information about the value $B(b, x)$ can be ascertained. Hence $\mathcal{A}$ cannot predict the first bit with a non-negligible advantage than a random guess.
}\begin{remark}
\DIFadd{Given a one-way function $f$, we can construct another one-way function $g$ with a hard concentrate bit. However, we may not be able to find a hard concentrate bit for $f$. In fact, it is an open question whether a hard concentrate bit exists for every one-way function.
}\end{remark}


\bigskip
\DIFadd{Intuitively, if a function $f$ is one-way, there should be a particular bit in the input $x$ that is hard to compute given $f(x)$. But this is not true:
}\begin{claim}
\DIFadd{If $f:\binset{n}\rightarrow \binset{n}$ is a one-way function, then there exists a one-way function $g:\binset{n+\log n}\rightarrow\binset{n+\log n}$ such that $\forall 1 \leq i \leq n+\log n$, $B_i(x) = x_i$ is not a hard concentrate bit, where $x_i$ is the $i^\text{th}$ bit of $x$.
}\end{claim}
\proof
\DIFadd{Define $g:\{0,1\}^{n+\log(n)} \rightarrow \{0,1\}^{n+\log(n)}$ as follows.
}$$\DIFadd{g(x,y) = f(x_{\bar y}) || x_y || y,}$$
\DIFadd{where $|x| = n, |y| = \log n$, $x_{\bar y}$ is all bits of $x$ except the $y^\text{th}$ bit, $x_y$ is the $y^\text{th}$ bit of $x$.
}

\DIFadd{First, one can show that $g$ is still a one-way function. }\peihan{leave this as an exercise?}
\DIFadd{We next show that $B_i$ is not a hard concentrate bit for $\forall 1 \leq i \leq n$ (clearly $B_i$ is not a hard concentrate bit for $n+1 \leq i \leq n+\log n$).
Construct an adversary $\mathcal{A}_i(1^{n+\log n}, f(x_{\bar y}) || x_y || y)$ that ``breaks'' $B_i$:
}\begin{itemize}
\item[\DIFadd{-}] \DIFadd{If $y \not= i$ then output a random bit;
}\item[\DIFadd{-}] \DIFadd{Otherwise output $x_y$.
}\end{itemize}
\begin{align*}
& \DIFadd{\Pr_{x, y}[\mathcal{A}(1^{n+\log n}, g(x,y)) = B_i(x)]}\\
\DIFadd{=}& \DIFadd{\Pr_{x, y}[\mathcal{A}(1^{n+\log n}, f(x_{\bar y}) || x_y || y) = x_i]}\\
\DIFadd{=}& \DIFadd{\frac{n-1}{n} \cdot \frac{1}{2} + \frac{1}{n} \cdot 1 = \frac{1}{2} + \frac{1}{2n}.
}\end{align*}
\DIFadd{Hence $\mathcal{A}_i$ can guess the output of $B_i$ with greater than $\frac{1}{2} + \mathsf{negl}(n)$ accuracy.
}\qed

\bigskip
\noindent\textbf{\DIFadd{Application: Coin tossing over the phone.}}
\DIFadd{Consider two parties trying to perform a coin tossing over the phone.  How can one party trust the win/loss response from the other party?  In particular, if one party calls out ``head'' and the other responds with ``tail'', the second party could be telling a lie.
A hard concentrate bit of a one-way permutation can resolve this issue.
}

\DIFadd{Let $f$ be a one-way permutation and $B$ be a hard concentrate bit for $f$. Consider the following protocol:
}\begin{itemize}
\item[\DIFadd{-}] \DIFadd{Party $P_1$ samples $x$ from $\{0,1\}^n$ uniformly at random and sends $f(x)$ to party $P_2$;
}\item[\DIFadd{-}] \DIFadd{$P_2$ sends back the choice for the coin, namely a single bit $b$;
}\item[\DIFadd{-}] \DIFadd{$P_1$ sends back $(x, B(x))$.  $B(x)$ serves as the outcome of the flipping.
}\end{itemize}
\DIFadd{On the one hand, $P_2$ cannot guess $B(x)$ with a non-negligible advantage than $1/2$.
On the other hand, $P_1$ cannot flip the value $B(b,x)$  because of the one-way fashion of $f$. }\peihan{$f$ has to be OWP, otherwise doesn't work}

\section{\DIFadd{One-Way Permutations with Hard Concentrate Bits}}
\DIFadd{We call a one-to-one (bijective) one-way function a one-way permutation (OWP for short).
Before delving into important characteristics of hard concentrate bits for one-way permutations, we consider an interesting application of hard concentrate bits and one-way permutations.
}





\bigskip
\DIFadd{Given a one-way permutation, we can construct a one-way permutation with a hard concentrate bit:
}\begin{theorem}
\DIFadd{Let  $f:\binset{n} \rightarrow \binset{n}$ be a one-way permutation.
Define a one-way permutation $f':\binset{2n} \rightarrow \binset{2n}$ as follows:
}$$\DIFadd{f'(x,r) = f(x) || r,}$$
\DIFadd{where $|x| = |r| =n$. It has the hard concentrate bit $B(x, r) = \sum_{i=1}^n x_i r_i\mod 2$.
}\end{theorem}
\proof
\peihan{TODO...}
\DIFadd{If $\exists$ non-uniform PPT adversary $\ma$ s.t. $\Pr_{x,r,A}[A(f'(x,r)) = B(x,r)] \ge \frac{1}{2} + \epsilon(n)$, where $\epsilon$ is non-$neg$, then $\exists$ an adversary $R$ that inverts $f$
}

	\DIFadd{First, note that $f'$ is a OWF function (as per last lecture).  Let $e^i$ be the value/binary string $0\ldots1\ldots0$, where the $1$ is in the $i$th position.}\\

\textbf{\DIFadd{Super simple case:}}\\
	\DIFadd{Assume that $A$ breaks the $B$ with perfect probability/accuracy: $\Pr[A(f'(x,r)) = B(x,r)] = 1$}\\
	\DIFadd{We will now construct an adversary $R(f(x))$ which yields $x$}\\
	\DIFadd{To invert $f$, $R$:
	}\begin{enumerate}
		\item \DIFadd{For each $i$, $R$ executes $A(f(x) \circ e^i)$
		}\item \DIFadd{Then $R$ XOR's (sums, modulo 2) the values from step $1$.  $A(f(x) \circ e^i) \rightarrow B(x, e^i) = \sum_{j=1}^n x_j e_j^i \mod 2  = x_i$
		}\item \DIFadd{$R$ concatenates each $x_i$ and returns the value as $x$
	}\end{enumerate}
	\DIFadd{Since $A$ predicts $B(f'(x,r))$ with probability 1, the output of $R$ is produced with probability $1$.}\\

\DIFadd{To begin with a more complicated case let us consider a set that gives us better probability than that in the theorem - a set that gives $\Pr[E] \ge \frac{1}{2} + \epsilon(n)$ (where $E$ is $A(f'(x,r)) = B(x,r)$ from the theorem statement).
Let us define this set as $G$ (standing for $Good$):}\\
\DIFadd{$\forall_{x \in G} \Pr_{r,A}[A(f'(x,r)) = B(x,r)] \ge \frac{1}{2} + \frac{\epsilon(n)}{2}$ with $\Pr[x \in G] \ge \frac{\epsilon(n)}{2}$ }\\
\\
\DIFadd{Assuming $\Pr[x \in G] \le \frac{\epsilon(n)}{2}$ implies a contradiction, so it is safe to conclude $\Pr[x \in G] \ge \frac{\epsilon(n)}{2}$}\\
\begin{proof}
\DIFadd{Assume that $\Pr[x \in G] \le \epsilon(n)/2$}\\
\DIFadd{$\frac{1}{2}+\epsilon(n) \le \Pr_{x,r,A}[E] = \Pr[E(x) | x \in G] \times \Pr[x \in G] + \Pr[E(x) | x \notin G] \times \Pr[x \notin G]$}\\
\DIFadd{$< 1 \times \frac{\epsilon(n)}{2} + (\frac{1}{2}+\frac{\epsilon(n)}{2}) \times 1 \le \frac{\epsilon(n)}{2} + \frac{1}{2}+\frac{\epsilon(n)}{2} = \frac{1}{2}+ \epsilon(n) \not> \frac{1}{2}+ \epsilon(n) contradiction$}\\
\DIFadd{$\implies \Pr[x \in G] \ge \frac{\epsilon(n)}{2}$}\\
\end{proof}
\\
	\DIFadd{Observe that $B(x,r) \oplus B(x, r\oplus e^i) = x_i$}\\
	\DIFadd{$= (\sum_j x_j r_j + \sum_j x_j r_j \oplus e^i_j) \mod 2$}\\
	\DIFadd{$= (\sum_j^{j \not= i} (x_j r_j + x_j r_j)$  $+ x_i r_i + x_i (1-r_i)) \mod 2$}\\
	\DIFadd{$= x_i r_i + x_i - x_i r_i = x_i$}\\\\

\DIFadd{Let us work with the probability: $\Pr_{r}[A(f(x), r) \oplus A(f(x), r \oplus e^i) = x_i]$}\\
		\DIFadd{Note that if both A's guess correctly, we get the right/intended answer.
		The probability of this happening $=$ both A's are right $=$ 1- either one is wrong $\ge  1-\frac{\text{either one is wrong}}{2 (\frac{1}{2}-\epsilon(n))} = 1 - \frac{\text{either one is wrong}}{2 \epsilon(n)}$}\\\\
\textbf{\DIFadd{The Simple Case:}}\\
	\DIFadd{$\Pr[E(x)] \ge \frac{3}{4}+\frac{\epsilon(n)}{2}$}\\
	\DIFadd{This probability, is bounded by $1-2(\frac{1}{4} - \frac{\epsilon(n)}{2}) = \frac{1}{2} + \epsilon(n)$ from the observation before (as $\text{one is wrong} = 1- (\frac{3}{4}+\frac{\epsilon(n)}{2}) = \frac{1}{4} - \frac{\epsilon(n)}{2}$)}\\
	\DIFadd{$R$ then runs the two A's polynomial times and uses majority vote.}\\
	\DIFadd{We use Chebyshev's inequality to justify the use of majority vote.
	%DIF > read chernov and chebyshev bounds
}

\subsection{\DIFadd{Chebyshev's inequality}} %DIF > TODO: should this be a subsection or should it be smaller?
	\DIFadd{Let $x_1,\ldots,x_m$ be independent and identical random variables assuming values 0 or 1.  Also, let $\Pr[x_i=1] = p$.}\\
		\DIFadd{Then $\Pr[ \lvert \sum x_i - pm \rvert > \delta m] < 1/(4\delta^2 m)$}\\

	\DIFadd{Let $b_1,\ldots,b_T$ be random bits.}\\
	\DIFadd{Let $X_1$ be 1 when $A(r_1) \rightarrow b_1$,}\\
	\DIFadd{$X_2$ be 1 when $A(r_2) \rightarrow b_2$,}\\
	\DIFadd{$\ldots$}\\
	\DIFadd{and let $X_T=1$ when $A(r_T) \rightarrow b_T$.}\\
	\DIFadd{Let $T=\frac{2n}{\epsilon(n)^2}$}\\\\

\DIFadd{The problematic case is:}\\
	\DIFadd{$\Pr[ \sum_{i=1}^T X_i \le T/2]$}\\
	\DIFadd{$= \Pr[ \sum_{i=1}^T X_i - (\frac{1}{2} + \epsilon(n)) T \le T/2 - (\frac{1}{2}+\epsilon(n))\times T]$}\\
	\DIFadd{$< \Pr[ \lvert \sum_{i=1}^T X_i - (\frac{1}{2}+\epsilon(n) T)\rvert > \epsilon(n) \frac{T}{2} ]$}\\
	\DIFadd{$< \frac{1}{4 (\epsilon(n)/2)^2 T} = \frac{1}{\epsilon(n)^2 T} = \frac{1}{2n}$ which is sufficient for the theorem}\\\\

\DIFadd{In order to show that we can use Chebyshev's inequality, we need to show that the samples we are voting over are pairwise independent:}\\
\DIFadd{For any two samples, - x,y - they are pair-wise independent if $\forall_{a,b \in {0,1}} \Pr[x=a \text{and} y=b] = \Pr[x=a] \times \Pr[y=b]$}\\

	\DIFadd{Imagine we have $(r_1, B(x, r_1)), \ldots, (r_T, B(x,r_T))$}\\
	\DIFadd{Let $k = \log(T)$, $S_1, \ldots, S_k \in \{0,1\}^n$ be sampled uniformly, and $b_1 = B(x, S_1), b_2 = B(x, S_2), \ldots, b_k = B(x, S_k)$
	$\forall_{Y \subseteq [k]}$, $R$ generates $(f(x, \bigoplus_{i \in Y} S_i), \bigoplus_{i \in Y} b_i)$}\\
	\DIFadd{(note: $[k]$ is the set $\{1,\ldots, k\}$)}\\
	\\
	\DIFadd{This proof is finished in the next lecture, with some slight changes.
}

\qed


%DIF > \subsection{Proof: Fixing a Value in a One-way Function}
%DIF > 
%DIF > \begin{theorem}
%DIF > Given a one-way function $f : \binset{n} \rightarrow \binset{m}$ and constants $x_0 \in \binset{n}$, $y_0 \in \binset{m}$, $\exists g : \binset{n} \rightarrow \binset{m}$ such that $g(x_0) = y_0$ where $g$ is a one-way function.\\
%DIF > \end{theorem}
%DIF > 
%DIF > Main Idea:  Set $g$ to be $f$, except at $x_0$, where $g(x_0) = y_0$.  If there exists an adversary that can break $g$, then that adversary will also break $f$, because the adversary can only know negligibly more information about $g$ than $f$.\\
%DIF > 
%DIF > \proof  Define the function $g$ as follows:
%DIF > 
%DIF > $g(x) = \left\{
%DIF > \begin{array}{lr}
%DIF >   y_0 & : x = x_0 \\
%DIF >   f(x) & : x \neq x_0
%DIF > \end{array}
%DIF > \right.$
%DIF > 
%DIF > Suppose there is an adversary $A$ that can break $g$ with non-negligible probability $\mu(n)$.\\
%DIF > 
%DIF > So, we have $\mu(n) = \underset{x \overset{\$}{\leftarrow} \binset{n}}{Pr} [ A(g(x)) \in g^{-1}(g(x)) ] = \sum\limits_{x \in \binset{n}} Pr(X = x) Pr [ A(g(x)) \in g^{-1}(g(x)) ]$\\
%DIF > 
%DIF > Since $x$ is uniformly distributed, $Pr[X = x] = \frac{1}{2^n}$.  We can split it into the cases $x : g(x) = y_0$ and $x : g(x) \neq y_0$:\\
%DIF > 
%DIF > $\mu(n) = \big[ \frac{1}{2^n} \sum\limits_{x \in \binset{n}, g(x) = y_0} Pr [ A(y_0) \in g^{-1}(y_0)) ] \big] + \big[ \frac{1}{2^n} \sum\limits_{x \in \binset{n}, g(x) \neq y_0} Pr [ A(g(x)) \in g^{-1}(g(x)) ] \big]$.\\
%DIF > 
%DIF > Let $p = | \{ x : g(x) = y_0 \} |$.  Consider the adversary $M$ where $M(y) = x_1$ for any $y$, where $x_1$ is a value of $x$ where $f(x_1) = y_0$.  Thus, $M$ breaks $f$ for any input where $f(x) = y_0$, of which there are $p - 1$ or $p$ (depending on whether $f(x_0) = y_0$).  So, the probability with which $M$ breaks $f$ is $\frac{p-1}{2^n}$ or $\frac{p}{2^n}$.  Either way, since $f$ is a one-way function, this implies that $\frac{p}{2^n}$ is a negligible function.\\
%DIF > 
%DIF > Now, since $Pr [ A(y_0) \in g^{-1}(g(x_0)) ] \leq 1$, we have:\\
%DIF > 
%DIF > $\mu(n) \leq \frac{p}{2^n} + \sum\limits_{x \in \binset{n}, g(x) \neq y_0} Pr [ A(g(x)) \in g^{-1}(g(x)) ]$\\
%DIF > 
%DIF > Notice that for any $x$ such that $g(x) \neq y_0$, we have $f(x) = g(x)$ and $f^{-1}(f(x)) = g^{-1}(g(x))$.\\
%DIF > 
%DIF > So $\mu(n) \leq \frac{p}{2^n} + \frac{1}{2^n}\sum\limits_{x \in \binset{n}, g(x) \neq y_0} Pr [ A(f(x)) \in f^{-1}(f(x)) ]$\\
%DIF > 
%DIF > Thus, if we consider $A$ as an adversary for $f$, then we get:\\
%DIF > 
%DIF > $\underset{x \overset{\$}{\leftarrow} \binset{n}}{Pr} [ A(f(x)) \in f^{-1}(f(x)) ] \; \geq \; \frac{1}{2^n}\sum\limits_{x \in \binset{n}, g(x) \neq y_0} Pr [ A(f(x)) \in f^{-1}(f(x)) ] \; \geq \; \mu(n) - \frac{p}{2^n}$\\
%DIF > 
%DIF > $\mu(n)$ is non-negligible and $\frac{p}{2^n}$ is negligible, and so, $\mu(n) - \frac{p}{2^n}$ is non-negligible.  Thus $A$ is an adversary that breaks $f$ with non-negligible probability.  \qed
%DIF > 
\fi

\section{\DIFadd{Pseudorandom Generators}}
\DIFadd{Now, we can define pseudorandom generators, which intuitively generates a polynomial number of bits that are computationally indistinguishable from being uniformly random:
}\begin{definition}
\DIFadd{A function $G:\{0,1\}^n\rightarrow \{0,1\}^{n+m}$ with $m = poly(n)$ is called a }\emph{\DIFadd{pseudorandom generator}} \DIFadd{if
}\begin{itemize}
\item \DIFadd{$G$ is computable in polynomial time.
}\item \DIFadd{$U_{n+m}\approx G(U_n)$, where $U_k$ denotes the uniform distribution on $\{0,1\}^k$.
}\end{itemize}
\end{definition}


\subsection{\DIFadd{PRG Extension}}
\DIFadd{In this section we show that any pseudorandom generator that produces one bit of randomness can be extended to create a polynomial number of bits of randomness.
}

\begin{construction}
\DIFadd{Given a PRG $G: \{0, 1\}^n \rightarrow \{0, 1\} ^ {n+1}$,
we construct a new PRG $F: \{0, 1\}^n \rightarrow \{0, 1\} ^{n+l}$ as follows ($l$ is polynomial in $n$).
}\begin{enumerate}[label=(\alph*)]
    \item \DIFadd{Input: $S_0 \xleftarrow{\$} \{0, 1\}^n$.
    }\item \DIFadd{$\forall i \in [l] = \{1, 2, \cdots, l\}$, $(\sigma_i, S_i) := G(S_{i-1})$, where $\sigma_i \in \{0, 1\}, S_i \in \{0, 1\}^n$ .
    }\item \DIFadd{Output: $\sigma_1 \sigma_2 \cdots \sigma_l S_l$.
}\end{enumerate}
\end{construction}

\begin{theorem}
\DIFadd{The function $F$ constructed above is a PRG.
}\end{theorem}

\proof
\DIFadd{We prove this by hybrid argument. Define the hybrid $H_i$ as follows.
}\begin{enumerate}[label=(\alph*)]
	\item \DIFadd{Input: $S_0 \xleftarrow{\$} \{0, 1\}^n$.
    }\item \DIFadd{$\sigma_1, \sigma_2, \cdots, \sigma_i \xleftarrow{\$} \{0, 1\}$, $S_i \gets S_0$.}\\
     \DIFadd{$\forall j \in \{i+1, i+2, \cdots, l\}$, $(\sigma_j, S_j) := G(S_{j-1})$, where $\sigma_j \in \{0, 1\}, S_j \in \{0, 1\}^n$ .
    }\item \DIFadd{Output: $\sigma_1 \sigma_2 \cdots \sigma_l S_l$.
}\end{enumerate}
\DIFadd{Note that $H_0 \equiv F$, and $H_l \equiv U_{n+l}$.
}

\DIFadd{Assume for the sake of contradiction that there exits a non-uniform PPT adversary $\ma$ that can distinguish $H_0$ form $H_l$.
Define $\epsilon_i := \Pr[\ma(1^n, H_i)=1]$ for $i = 0, 1, \cdots, l$.
Then there exists a non-negligible function $v(n)$ such that $|\epsilon_0 - \epsilon_l| \geq v(n)$.
Since
}\[
\DIFadd{|\epsilon_0 - \epsilon_1| +
|\epsilon_1 - \epsilon_2| +
\cdots +
|\epsilon_{l-1} - \epsilon_l| \geq
|\epsilon_0 - \epsilon_l|
\geq v(n),
}\]
\DIFadd{there exists $k \in \{0, 1, \cdots, l-1\}$ such that
}\[
\DIFadd{|\epsilon_{k} - \epsilon_{k+1}| \geq \frac{v(n)}{l}.
}\]
\DIFadd{$l$ is polynomial in $n$, hence $\frac{v(n)}{l}$ is also a non-negligible function.
That is to say, $\ma$ can distinguish $H_{k}$ from $H_{k+1}$.
Then we use $\ma$ to construct an adversary $\mathcal{B}$ that can distinguish $U_{n+1}$ from $G(U_n)$ (which leads to a contradiction):
On input $T \in \{0, 1\}^{n+1}$ ($T$ could be either from $U_{n+1}$ or $G(U_n)$), $\mathcal{B}$ proceeds as follows:
}\begin{itemize}
\item \DIFadd{$\sigma_1, \sigma_2, \cdots, \sigma_k \xleftarrow{\$} \{0, 1\}$, $(\sigma_{k+1}, S_{k+1}) \gets T$.
}\item \DIFadd{$\forall j \in \{k+2, k+3, \cdots, l\}$, $(\sigma_j, S_j) := G(S_{j-1})$, where $\sigma_j \in \{0, 1\}, S_j \in \{0, 1\}^n$ .
}\item \DIFadd{Output: $\ma(1^n, \sigma_1 \sigma_2 \cdots \sigma_l S_l)$.
}\end{itemize}

\DIFadd{First, since $\ma$ and $G$ are both PPT computable, $\mathcal{B}$ is also PPT computable.
}

\DIFadd{Second, if $T\gets G(U_n)$, then $\sigma_1 \sigma_2 \cdots \sigma_l S_l$ is the output of  $H_{k}$; if $T \stackrel{\$}\leftarrow U_{n+1}$, then $\sigma_1 \sigma_2 \cdots \sigma_l S_l$ is the output of $H_{k+1}$.
Hence
}\begin{align*}
&\DIFadd{\big|\Pr[\mathcal{B}(1^n, G(U_n)) = 1] - \Pr[\mathcal{B}(1^n, U_{n+1}) = 1]\big|}\\
\DIFadd{=}& \DIFadd{\big|\Pr[\ma(1^n,H_k) = 1] - \Pr[\ma(1^n,H_{k+1}) = 1]\big|}\\
\DIFadd{=}&
\DIFadd{|\epsilon_{k} - \epsilon_{k+1}| \geq \frac{v(n)}{l}.
}\end{align*}
\qed

\subsection{\DIFadd{PRG from OWP (One-Way Permutations)}}
\DIFadd{In this section we show how to construct pseudorandom generators under the assumption that one-way permutations exist.
}

\begin{construction}
\DIFadd{Let $f: \{0, 1\}^n \rightarrow \{0, 1\}^n$ be a OWP. We construct $G: \{0, 1\}^{2n} \rightarrow \{0, 1\}^{2n+1}$ as
}\[
\DIFadd{G(x, r) = f(x) || r || B(x, r),
}\]
\DIFadd{where $x, r \in \{0, 1\}^n$, and $B(x, r)$ is a hard concentrate bit for the function $g(x,r) = f(x) || r$.
}\end{construction}

\begin{remark}
\DIFadd{The hard concentrate bit $B(x,r)$ always exists. Recall Theorem~\ref{thm:hard-concentrate-bit},
}\[\DIFadd{B(x,r) = \left(\sum_{i=1}^n x_i r_i\right)\mod 2}\]
\DIFadd{is a hard concentrate bit.
}\end{remark}

\begin{theorem}
\DIFadd{The $G$ constructed above is a PRG.
}\end{theorem}

\proof
\DIFadd{Assume for the sake of contradiction that $G$ is not PRG.
We construct three ensembles of probability distributions:
}\[\DIFadd{H_0 := G(U_{2n}) = f(x) || r || B(x, r), \text{ where } x, r \xleftarrow{\$} \{0, 1\}^n;}\]
\[\DIFadd{H_1 := f(x) || r || \sigma, \text{ where } x, r \xleftarrow{\$} \{0, 1\}^n, \sigma \xleftarrow{\$} \{0, 1\};}\]
\[\DIFadd{H_2 := U_{2n+1}.}\]

\DIFadd{Since $G$ is not PRG, there exists a non-uniform PPT adversary $\ma$ that can distinguish $H_0$ from $H_2$.
Since $f$ is a permutation, $H_1$ is uniformly distributed in $\{0, 1\}^{2n+1}$, i.e., $H_1 \equiv H_2$.
Therefore, $\ma$ can distinguish $H_0$ from $H_1$,
that is, there exists a non-negligible function $v(n)$ satisfying
}\[
\DIFadd{\big| \Pr[\ma(H_0)=1] - \Pr[\ma(H_1)=1] \big| \geq v(n).
}\]

\DIFadd{Next we will construct an adversary $\mathcal{B}$ that ``breaks'' the hard concentrate bit (which leads to a contradiction).
Define a new ensemble of probability distribution
}\[
\DIFadd{H_1' = f(x) || r || (1-B(x, r)) , \text{ where } x, r \xleftarrow{\$} \{0, 1\}^n.
}\]
\DIFadd{Then we have
}\begin{align*}
\DIFadd{\Pr[\ma(H_1) = 1]
=}& \DIFadd{\Pr[\sigma = B(x, r)] \Pr[A(H_0) = 1] + \Pr[\sigma = 1 - B(x, r)] \Pr[A(H_1') = 1]}\\
\DIFadd{=}& \DIFadd{\frac{1}{2} \Pr[A(H_0) = 1] + \frac{1}{2}\Pr[A(H_1') = 1].
}\end{align*}
\DIFadd{Hence
}\begin{align*}
&\DIFadd{\Pr[A(H_1) = 1] - \Pr[A(H_0) = 1]
=  \frac{1}{2}\Pr[A(H_1') = 1] - \frac{1}{2} \Pr[A(H_0) = 1],
}\\
&\DIFadd{\frac{1}{2} \left|\Pr[A(H_0) = 1] - \Pr[A(H_1') = 1] \right|
= \left| \Pr[A(H_1) = 1] - \Pr[A(H_0) = 1] \right|
\geq v(n),
}\\
&\DIFadd{\left|\Pr[A(H_0) = 1] - \Pr[A(H_1') = 1] \right|
\geq 2v(n).
}\end{align*}

\DIFadd{Without loss of generality, we assume that
}\[
\DIFadd{\Pr[A(H_0) = 1] - \Pr[A(H_1') = 1]
\geq 2v(n).
}\]
\DIFadd{Then we construct $\mathcal{B}$ as follows:
}\[
\DIFadd{\mathcal{B}(f(x)|| r) :=
\begin{cases}
\sigma, & \text{if } \ma(f(x)|| r||\sigma) = 1\\
1 - \sigma, & \text{if } \ma(f(x)||r|| \sigma) = 0
\end{cases},
}\]
\DIFadd{where $\sigma \xleftarrow{\$} \{0, 1\}$.
Then we have
}\begin{align*}
& \DIFadd{\Pr[\mathcal{B}(f(x)|| r) = B(x, r)]}\\
\DIFadd{=}& \DIFadd{\Pr[\sigma = B(x, r)] \Pr[ \ma(f(x)|| r||\sigma)=1 | \sigma = B(x, r)] + }\\
& \DIFadd{\Pr[\sigma = 1 - B(x, r)] \Pr[ \ma(f(x)|| r||\sigma) = 0 | \sigma = 1- B(x, r)] + }\\
\DIFadd{=}& \DIFadd{\frac{1}{2} \big( \Pr[\ma(f(x)||r||B(x, r)) = 1] + 1 - \Pr[\ma(f(x)|| r|| 1- B(x, r)) = 1] \big)}\\
\DIFadd{=}& \DIFadd{\frac{1}{2} + \frac{1}{2} \big( \Pr[A(H_0) = 1] - \Pr[A(H_1') = 1] \big)}\\
\DIFadd{\geq }& \DIFadd{\frac{1}{2} + v(n).
}\end{align*}
\DIFadd{This contradicts the fact that $B$ must be a hardness concentrate bit.
}\qed


\section{\DIFadd{Pseudorandom Functions}}
\DIFadd{In this section, we first define pseudorandom functions, and then show how to  construct a pseudorandom function from a pseudorandom generator.
}

\DIFadd{Considering the set of all functions $f: \{0, 1\}^n \rightarrow \{0, 1\}^n$, there are $(2^n)^{2^n}$ of them.
To describe a random function in this set we need $n \cdot 2^n$ bits.
Intuitively, a pseudorandom function is one that cannot be distinguished from a random one,
but needs much fewer bits (e.g., polynomial in $n$) to be described.
Note that we restrict the distinguisher to only being allowed to ask the function poly($n$) times and decide whether it is random or pseudorandom.
}

\subsection{\DIFadd{Definitions}}

\begin{definition}[Function Ensemble]
    \DIFadd{A }\emph{\DIFadd{function ensemble}} \DIFadd{is a sequence of random variables $F_1, F_2, \cdots, F_n, \cdots$ denoted as $\{F_n\}_{n \in \mathbb{N}}$ such that
    $F_n$ assumes values in the set of functions mapping $n$-bit input to $n$-bit output.
}\end{definition}
\DIFadd{Although we will only focus on the functions where the input and output bit-length is the same, the definition can be generalized to functions mapping $n$-bit inputs to $m$-bit outputs as $\{F_{n, m}\}_{n, m \in \mathbb{N}}$.
}

\begin{definition}[Random Function Ensemble]
    \DIFadd{We denote a random function ensemble by $\{R_n\}_{n \in \mathbb{N}}$.
}\end{definition}
\DIFadd{A sampling of the random variable $R_n$ requires $n \cdot 2^n$ bits to describe.
}

\begin{definition}[Efficiently Computable Function Ensemble]
    \DIFadd{A function ensemble is called }\emph{\DIFadd{efficiently computable}} \DIFadd{if
    }\begin{enumerate}[label=(\alph*)]
        \item \textbf{\DIFadd{Succinct}}\DIFadd{:
              $\exists$ a PPT algorithm $I$ and a mapping $\phi$ from strings to functions such that
              $\phi(I(1^n))$ and $F_n$ are identically distributed.
              Note that we can view the output of $I(\cdot)$ as the description of the function.
        }\item \textbf{\DIFadd{Efficient}}\DIFadd{:
              $\exists$ a poly-time machine $V$ such that
              $V(i, x) = f_i(x)$ for every $x \in \{0, 1\}^n$, where $i$ is in the range of $I(1^n)$, and $f_i = \phi(i)$.
    }\end{enumerate}
\end{definition}

\DIFadd{Note that the succinctness condition implies that a sample from $F_n$ can be equivalently generated by first sampling a random string $k$ from $\{0, 1\}^n$, and then outputting $f_k$. Here $k$ is often called the ``key'' of the function}\footnote{\DIFadd{An efficiently computable function requires only $n$ bits (the key) to describe, while a random function requires $n.2^n$ bits.}}\DIFadd{. More generally, the key can be a string of length $m$ where $n$ is polynomial in $m$; here $I$ uses a random tape of length $m$ and outputs $n$ bits. %DIF > However, we will only consider the case where the key is of length $n$.
}

\begin{definition}[Pseudorandom Function Ensemble]
    \DIFadd{A function ensemble $F = \{F_n\}_{n \in \mathbb{N}}$ is }\emph{\DIFadd{pseudorandom}} \DIFadd{if
    for every non-uniform PPT oracle adversary $\ma$, there exists a negligible function $\epsilon(n)$ such that
    }\[
        \DIFadd{\big| \Pr[\ma^{F_n} (1^n) = 1] - \Pr[\ma^{R_n} (1^n) = 1]  \big| \leq \epsilon(n).
    }\]
    \DIFadd{Here by saying ``oracle'' it means that $\ma$ has ``oracle access'' to a (fixed) function (in our definition, the function is a sampling of $F_n$ or $R_n$), and each call to that function costs 1 unit of time.
}\end{definition}

\DIFadd{Note that we will only consider efficiently computable pseudorandom ensembles in the following. Therefore, each function in $F_n$ is defined by a PRF key $k \in \{0, 1\}^n$.
}


\subsection{\DIFadd{Construction of PRF from PRG}}

\begin{construction}
    \DIFadd{Given a PRG $G: \{0, 1\}^n \rightarrow \{0, 1\}^{2n}$,
    let $G_0(x)$ be the first $n$ bits of $G(x)$, $G_1(x)$ be the last $n$ bits of $G(x)$.
    We construct $F^{(K)}: \{0, 1\}^n \rightarrow \{0, 1\}^n$ as follows.
    }\[
        \DIFadd{F^{(K)}_n(x_1 x_2 \cdots x_n) := G_{x_n}(G_{x_{n-1}} (\cdots(G_{x_1}(K)) \cdots  )),
    }\]
    \DIFadd{where $K \in \{0,1\}^n$ is the key to the pseudorandom function. In Figure \ref{fig:binary-tree}, $i = K$.
}\end{construction}
\DIFadd{The construction can be viewed as a binary tree of depth $n$, as shown in Figure \ref{fig:binary-tree}}\footnote{\DIFadd{Algorithmically, $F_n^{(K)}(x)$ is computed as:
}\begin{enumerate}
    \item \DIFadd{Set $y \gets K \in \{0, 1\}^n$.
    }\item \DIFadd{For $i = 1 \dots n$: update $y \gets G_{x_i}(y)$.
    }\item \DIFadd{Output $y$.
}\end{enumerate}
}\DIFadd{.
}

\begin{marginfigure}
    \centering
    \includegraphics[width=\textwidth]{Old Scribe Notes/binary-tree.pdf}
    \caption{\DIFadd{View the construction as a binary tree}}
    \label{fig:binary-tree}
\end{marginfigure}

\begin{theorem}\label{theorem:ggm}
    \DIFadd{The function ensemble $\{F_n\}_{n \in \mathbb{N}}$ constructed above is pseudorandom.
}\end{theorem}

\proof
\DIFadd{Assume for the sake of contradiction that $\{F_n\}_{n \in \mathbb{N}}$ is not a PRF.
Then there exists a non-uniform PPT oracle adversary $\ma$ that can distinguish $\{F_n\}_{n \in \mathbb{N}}$ from $\{R_n\}_{n \in \mathbb{N}}$. Below, via a hybrid argument, we prove that this contradicts the fact that $G$ is a PRG; we will construct an adversary $\mathcal{B}$ that can distinguish between a sample from $U_{2n}$ and $G(U_{n})$. We will prove for a fixed $n$, and the proof can be easily extended to all $n \in \mathbb{N}$.}\smallskip

\noindent \textbf{\DIFadd{Hybrids}}\DIFadd{. Consider the sequence of hybrids $H_i$ for $i \in \{ 0, 1, \cdots, n\}$ where the hybrid $i$ is defined as follows:
}\[\DIFadd{H_{i}^{(K_i)} (x_1x_2\ldots x_n ):= G_{x_n}(G_{x_{n-1}} (\cdots(G_{x_{i+1}}(K_i(x_1\dots x_{i-1}x_i))) \cdots  )), }\]
\DIFadd{where $K_i$ is a random function from $\{0,1\}^{i}$ to $\{0,1\}^n$. Intuitively, hybrid $H_i$ corresponds to a binary tree of depth $n$ where the nodes of levels $0$ to $i$ correspond to random values and the nodes at levels $i+1$ to $n$ correspond to pseudorandom values. By inspection, observe that hybrids $H_0$ and $H_n$ are identical to a pseudorandom function and a random function, respectively. Note that we cannot yet reduce the computational indistinguishability of $H_i$ and $H_{i+1}$ to security of the PRG $G$ because the adversary can make multiple oracle queries at different inputs.}\smallskip

\noindent \textbf{\DIFadd{Sub-hybrids}}\DIFadd{. We show that $H_{i}$ and $H_{i+1}$ are indistinguishable by considering a sequence of sub-hybrids $H_{i,j}$ for $j \in \{0,\ldots q\}$, where $q$ is the number of oracle queries made by $\mathcal{A}$}\footnote{\DIFadd{Observe that $\mathcal{A}$ can make at most polynomial in $n$ oracle queries. Looking ahead, our outer adversary $\mathcal{B}$ can either take $q$ as the max queries allowed to $\mathcal{A}$, or guess the number, and double the guess each time if it's an under-estimate.}}\DIFadd{.
Intuitively, with each sub-hybrid $H_{i,j}$, at level $i+1$ in the tree, we will fix the first $j$ oracle queries made by $\mathcal{A}$ to be output of random functions and the rest to be output of PRG. Let $R_i: \{0, 1\}^i \to \{0, 1\}^n$ and $S_{i}: \{0, 1\}^{i+1} \to \{0, 1\}^n$ be two random functions.
We define sub-hybrid $H_{i,j}^{(R_i, S_{i})}(x_1x_2\dots x_n)$ algorithmically as follows:
}\begin{enumerate}
    \item \DIFadd{Initialize a list $L \gets \{\}$ to store the $i$-bit prefixes of the queries made by $\mathcal{A}$.
    }\item \DIFadd{If $|L| < j$ or $(x_1\dots x_i) \in L$}\footnote{\DIFadd{Captures the first $j$ queries or any query with repeated $i$-bit prefix to a previous query.}}\DIFadd{:
          }\begin{enumerate}[noitemsep,nolistsep]
              \item \DIFadd{Set $y \gets S_i(x_1\dots x_i x_{i+1})$.
              }\item \DIFadd{Append $(x_1\dots x_i)$ to $L$.
              }\item \DIFadd{For $a \in i+2 \dots n$: update $y \gets G_{x_a}(y)$.
          }\end{enumerate}
    \item \DIFadd{Else:
          }\begin{enumerate}[noitemsep,nolistsep]
              \item \DIFadd{Set $y \gets R_i(x_1\dots x_i)$.
              }\item \DIFadd{For $a \in i+1 \dots n$: update $y \gets G_{x_a}(y)$.
          }\end{enumerate}
    \item \DIFadd{Output $y$.
}\end{enumerate}

\DIFadd{Note that $H_{i, 0}$ is the same as $H_i$ and $H_{i, q}$ is the same as $H_{i+1}$. Since we assumed that $\mathcal{A}$ can distinguish between $H_0$ and $H_n$, by triangle inequality, there exists a $i^*, j^*$ such that it can distinguish $H_{i^*,j^*}$ and $H_{i^*,j^*+1}$. We now focus on these two sub-hybrids}\footnote{\DIFadd{Looking ahead, the outer adversary $\mathcal{B}$ can guess $i^*, j^*$; total choices are bounded by polynomial in $n$. To simplify the proof, we will assume that $\mathcal{B}$ already knows this $i^*, j^*$.}}\DIFadd{. Consider the $j^*+1$-th query made by $\mathcal{A}$ (i.e. the first query where $|L|=j$). Observe that this query cannot have the same $i$-bit prefix as any of the previous queries. Because if it did, then the output distribution of the two hybrids would be identical, and that contradicts our assumption about $\mathcal{A}$'s distinguishing power. Therefore, the $j^*+1$-th query has to be a new query, and this query is the only place where the two hybrids differ.}\smallskip

\noindent \textbf{\DIFadd{Outer adversary $\mathcal{B}$}}\DIFadd{. Now we are ready to construct our outer adversary $\mathcal{B}$ that can distinguish between $U_{2n}$ and $G(U_n)$. $\mathcal{B}^{\mathcal{A}, i^*, j^*}(1^n, z)$, where $z \in \{0, 1\}^{2n}$ ($z$ could be either from $U_{2n}$ or $G(U_n)$) and we assume the knowledge of $i^*, j^*$}\footnote{\DIFadd{As mentioned before, it can be guessed with slight loss in distinguishing advantage.}}\DIFadd{, operates as follows:
}\begin{enumerate}
    \item \DIFadd{Parse $z$ as $z_0||z_1$, where $z_0, z_1 \in \{0, 1\}^n$.
    }\item \DIFadd{For all the oracle queries from $\mathcal{A}$ except the $j^*+1$-th query, respond as $H_{i^*,j^*}$}\footnote{\DIFadd{The outer adversary $\mathcal{B}$ runs a random function in polynomial time in $n$ via lazy sampling. It generates a random output on a new input and caches responses to previous inputs.}}\DIFadd{.
    }\item \DIFadd{For the $j^*+1$-th query $(x_1\dots x_n)$, do the following:
          }\begin{enumerate}
              \item \DIFadd{Set $y \gets z_{x_{i^*+1}}$.
              }\item \DIFadd{For $a \in i^*+2 \dots n$: update $y \gets G_{x_a}(y)$.
              }\item \DIFadd{Respond with $y$.
          }\end{enumerate}
    \item \DIFadd{Output whatever $\mathcal{A}$ outputs.
}\end{enumerate}

\DIFadd{We assumed that $\mathcal{A}$ can distinguish between $H_{i^*, j^*}$ and $H_{i^*, j^*+1}$, so by contrapositive of the Sunglass Lemma, $\mathcal{B}$ can distinguish between $U_{2n}$ and $G(U_n)$. This contradicts that $G$ is a PRG.
}

%DIF > where $q_{i+1}$ is the number of the distinct $i-bit$ prefixes of the queries of $\mathcal{A}$.\footnote{Observe that $q_{i+1}$ for each appropriate choice of $i$ is bounded by the running time of $\mathcal{A}$. Hence, this value is bounded by a polynomial in the security parameter.}
%DIF > We define hybrid $H_{i,j}$ for $j =0$ to be same as hybrid $H_{i}$. Additionally, for $j >0$ hybrid $H_{i,j}$ is defined to be exactly the same as hybrid $H_{i,j-1}$ except the response provided to the attacker for the $j^{th}$ distinct $i-bit$ prefix query of $\mathcal{A}$. Let this prefix be $x^*_n x^*_{n-1} \ldots x^*_{i}$. Note that in hybrid $H_{i,j-1}$ the children of the node $x^*_n x^*_{n-1} \ldots x^*_{i}$ correspond to two pseudorandom values. In hybrid $H_{i,j}$ we replace these two children with random values. By careful inspection, it follows that hybrid $H_{i,q_{i+1}}$ is actually $H_{i+1}$. All we are left to prove is that hybrid $H_{i,j}$ and $H_{i,j+1}$ are indistinguishable for the appropriate choices of $j$ and we prove this below.
%DIF > Now we are ready to construct an adversary $\mathcal{B}$ that  distinguishes $U_{2n}$ from $G(U_n)$: On input $T \in\{0, 1\}^{2n}$ ($T$ could be either from $U_{2n}$ or $G(U_n)$),
%DIF > construct a full binary tree of depth $n$ that is exactly the same as $H_{i,j}$ except replacing the children of  $x^*_n x^*_{n-1} \ldots x^*_{i}$ by the value $T$.
%DIF > Observe that the only difference between $H_{i,j}$ and $H_{i,j+1}$ is that values corresponding to nodes $x_n^*\ldots x_i^* 0$ and $x_n^*\ldots x_i^* 1$ are pseudorandom or random respectively. $\mathcal{B}$ uses the value $T$ to generate these two nodes. Hence success in  distinguishing hybrids $H_{i,j}$ and $H_{i,j+1}$ provides a successful attack for $\mathcal{B}$ in violating security of the pseudorandom generator.
\qed







\section{\DIFadd{PRFs from DDH: Naor-Reingold PRF}}
\DIFadd{We will now describe a PRF function family $F_n: \mathcal{K} \times \{0,1\}^n \rightarrow \mathbb{G}_n$ where DDH is assumed to be hard for  $\{\mathbb{G}_n\}$ and $\mathcal{K}$ is the key space.
The key for the PRF $F_n$ will be $K =  (h, u_1, \ldots u_n)$, where $u,u_0\ldots u_n$ are sampled uniformly from $|\mathbb{G}_n|$, $g$ is the generator of $\mathbb{G}_n$ and $h = g^u$. Compared to the previous construction (Theorem~\ref{theorem:ggm}), there are two differences to note already: the key is polynomially longer and the output space is $\mathbb{G}_n$ instead of $\{0, 1\}^n$.
}

\[\DIFadd{F_n(K,x) = h^{\prod_{i} u_i^{x_i}}}\]

\DIFadd{Next, we will prove that the function $F_n$ is a pseudo-random function or that $\{F_n\}$ is a pseudo-random function ensemble.}\footnote{\DIFadd{Here, we require that adversary distinguish the function $F_n$ from a random function from $\{0,1\}^n$ to $\mathbb{G}_n$. Note that the output range of the function is $\mathbb{G}_n$. Moreover, note that the distribution of random group elements in $\mathbb{G}_n$ might actually be far from uniformly random strings.}}
\begin{lemma}
    \DIFadd{Assuming the DDH Assumption (see Definition~\ref{def:ddh}) for $\{\mathbb{G}_n\}$ is hard, we have that $\{F_n\}$ is a pseudorandom function ensemble.
}\end{lemma}
\begin{proof}
    \DIFadd{The proof of this lemma is similar to the proof of Theorem~\ref{theorem:ggm} except for some subtle differences that arise from number theory}\footnote{\DIFadd{At a high-level, we can no longer fix nodes in the same level of the tree arbitrarily. Fixing one node has implications for how other nodes will be changed. This is because we have a fixed basis in the key.}}\DIFadd{.
}

    \DIFadd{Let $R_n$ be random function from $\{0,1\}^n \rightarrow \mathbb{G}_n$. Then we want to prove that for all non-uniform PPT adversaries $\mathcal{A}$ we have that:
    }\[\DIFadd{\mu(n) = \left|\Pr[\mathcal{A}^{F_n}(1^n) =1] -  \Pr[\mathcal{A}^{R_n}(1^n) =1]\right|}\]
    \DIFadd{is a negligible function. }\smallskip

    \noindent \textbf{\DIFadd{Hybrids}}\DIFadd{. For the sake of contradiction, we assume that the function $F_n$ is not pseudorandom. Next, towards a contradiction, we consider a sequence of hybrid functions $H^0_n \ldots H^n_n$.
    For $j \in \{0, \dots, n\}$, let $S^j_n: \{0, 1\}^j \to \{0, 1, \dots, |\mathbb{G}_n|-1\}$, then hybrid $H_n^j$ is defined as}\footnote{\DIFadd{Algorithmically, $H_n^j((u,u_{j+1}\ldots u_n),x)$ is computed as:
    }\begin{enumerate}
        \item \DIFadd{Set $y \gets S_n^j(x_1\ldots x_j)$.
        }\item \DIFadd{For $i = j+1 \dots n$: update $y \gets y \cdot u_i^{x_i}$.
        }\item \DIFadd{Output $g^y$.
    }\end{enumerate}

    }\DIFadd{:
    }\begin{equation*}
        \DIFadd{H_n^j((u,u_{j+1}\ldots u_n),x) = \big(g^{S_n^j(x_1\ldots x_j)}\big)^{\prod_{i=j+1}^n u_i^{x_i}}
    }\end{equation*}
    \DIFadd{where $S_n^0(\cdot)$ is the constant function with output $u$. Observe that $H_n^0$ is the same as the function $F_n$ and $H_n^n$ is the same as the function $R_n$}\footnote{\DIFadd{A uniform group element is equivalently sampled by first sampling an exponent in the order of the group.}}\DIFadd{. Thus, by a hybrid argument and triangle inequality, we conclude that there exists $j^* \in \{0,\ldots n-1\}$, such that
    }\[\DIFadd{\left|\Pr[\mathcal{A}^{H_n^{j^*}}(1^n) =1] -  \Pr[\mathcal{A}^{H_n^{j^*+1}}(1^n) =1]\right|}\]
    \DIFadd{is a non-negligible function. Now all we are left to show is that this implies an attacker that refutes the DDH assumption.}\smallskip

    \noindent \textbf{\DIFadd{Sub-hybrids}}\DIFadd{. The proof of this claim follows by a sequence of $q+1$ sub-hybrids $H_n^{j, 0}, \dots, H_n^{j, q}$, where $q$ is the (polynomially bounded by $n$) running time of $\mathcal{A}$. For the simplicity of exposition, we abuse the notation and denote $q(n)$ by $q$. Let $C_n^j: \{0, 1\}^j \to \{0, \dots, |\mathbb{G}_n|-1\}$ and $D_n^j: \{0, 1\}^{j+1} \to \{0, \dots, |\mathbb{G}_n|-1\}$ be two random functions, and $C_n^0(\cdot) = u$. We define sub-hybrid $H_n^{j, k}\big((u, u_{j+1}\ldots u_n),(x_1\dots x_n)\big)$ for $k \in \{0, \dots, q\}$ as follows:
    }\begin{enumerate}
        \item \DIFadd{Initialize a list $L \gets \{\}$ to store the $j$-bit prefixes of the queries made by $\mathcal{A}$.
        }\item \DIFadd{If $|L|<k$ or $(x_1\cdots x_j) \in L$:
              }\begin{enumerate}[noitemsep,nolistsep]
                  \item \DIFadd{Set $y \gets D^j_n(x_1\dots x_{j+1})$.
                  }\item \DIFadd{Append $(x_1\dots x_j)$ to $L$.
                  }\item \DIFadd{For $i = j+2 \dots n$: update $y \gets y \cdot u_i^{x_i}$.
              }\end{enumerate}
        \item \DIFadd{Else
              }\begin{enumerate}[noitemsep,nolistsep]
                  \item \DIFadd{Set $y \gets C^j_n(x_1\dots x_j)$.
                  }\item \DIFadd{For $i = j+1 \dots n$: update $y \gets y \cdot u_i^{x_i}$.
              }\end{enumerate}
        \item \DIFadd{Output $g^y$.
    }\end{enumerate}

    \DIFadd{It is easy to see that $H_n^{j, 0}$ is the same as $H_n^j$ and $H_n^{j, q}$ is the same as $H_n^{j+1}$.
    Again, we use hybrid argument to conclude that there exists $j^*, k^*$ such that $\mathcal{A}$ can distinguish between $H_n^{j^*, k^*}$ and $H_n^{j^*, k^*+1}$ with non-negligible probability. We now focus on these two sub-hybrids. Consider the $k^*+1$-th oracle query made by $\mathcal{A}$. Following an identical argument we used in the proof of Theorem~\ref{theorem:ggm}, this query cannot be a repeat of a query made before, and this query is the only place where the two sub-hybrids differ.}\smallskip

    \noindent \textbf{\DIFadd{Outer adversary $\mathcal{B}$}}\DIFadd{. The construction of the outer adversary $\mathcal{B}$ is a bit different from the proof of Theorem~\ref{theorem:ggm}. Intuitively, unlike Theorem~\ref{theorem:ggm}, outer adversary cannot simply replace the $k^*+1$-th query with the DDH challenge in isolation from the rest of the queries made by $\mathcal{A}$. This is because the pseudorandom nodes in the tree are tied together by the DDH relation, and are not independent, i.e., all pseudorandom sibling nodes on the same level of the tree are set apart by a common exponent.
}

    \DIFadd{$\mathcal{B}$ gets as challenge either a DDH tuple $(g, A=g^a, B=g^b, C=g^{ab})$ or a uniform tuple $(g, A=g^a, B=g^b, C=g^c)$ where $a, b, c$ are uniform in $\{0, \dots, |\mathbb{G}|-1\}$. We construct $\mathcal{B}^{\mathcal{A}, j^*, k^*}\big(1^n, (g, A, B, C)\big)$ as follows:
    }\begin{enumerate}
        \item \DIFadd{Sample $u, u_{j^*+1}, \ldots u_n$ uniformly from $\{0, \dots, |\mathbb{G}_n|-1\}$.
        }\item \DIFadd{For first $k^*$ queries from $\mathcal{A}$, respond as $H_n^{j^*, k^*}((u, u_{j^*+1}, \ldots u_n),\cdot)$.
        }\item \DIFadd{For the $k^*+1$-th query $(x_1\ldots x_n)$, do the following:
              }\begin{enumerate}[noitemsep,nolistsep]
                  \item \DIFadd{Set $y \gets A$ if $x_{j^*+1} = 0$ and $y \gets C$ if $x_{j^*+1} = 1$.
                  }\item \DIFadd{For $i = j^*+2 \dots n$: update $y \gets y \cdot u_i^{x_i}$.
                  }\item \DIFadd{Output $g^y$.
              }\end{enumerate}
        \item \DIFadd{For the rest of the queries $(x_1\ldots x_n)$, do the following:
              }\begin{enumerate}[noitemsep,nolistsep]
                  \item \DIFadd{Set $y \gets C^j_n(x_1\ldots x_j)$.
                  }\item \DIFadd{For $i = j^*+2 \dots n$: update $y \gets y \cdot u_i^{x_i}$.
                  }\item \DIFadd{If $x_{j^*+1} = 0$, output $g^y$, else output}\footnote{\DIFadd{Recall that $B=g^b$, so $B^y = g^{y\cdot b} = g^{y\cdot b^x_{j^*+1}}$. Therefore, the DDH relation is properly set for all pseudorandom nodes.}} \DIFadd{$B^y$.
              }\end{enumerate}
        \item \DIFadd{Output whatever $\mathcal{A}$ outputs.
    }\end{enumerate}

    \DIFadd{By the construction of $\mathcal{B}$, if $(g, A, B, C)$ is a DDH tuple, then the distribution of oracle responses seen by $\mathcal{A}$ are exactly the same as the responses seen in the hybrid $H_n^{j^*, k^*}$. Otherwise, they are the same as hybrid $H_n^{j^*, k^*+1}$.
    We assumed that $\mathcal{A}$ can distinguish between $H_n^{j^*, k^*}$ and $H_n^{j^*, k^*+1}$, therefore $\mathcal{B}$ can distinguish between a DDH tuple and a uniform tuple. This contradicts our assumption that DDH is hard.
}

    %DIF > Without loss of generality we assume that $\mathcal{A}$ never makes the same query twice.
    %DIF > More specifically, we consider a sequence of functions $F_n^{k,t}$ where $t \in \{0,T\}$, $F_n^{k,0}$ is same as $F_n^{k}$ and $F_n^{k,T}$ is same as $F_n^{k+1}$. In particular, we explain how $F_n^{k,t}$ answers queries by $\mathcal{A}$.\footnote{As assumed earlier, keep in mind that $\mathcal{A}$ never makes the same query twice.} Let $x^1, \ldots x^t$ be the first $t$ queries made by $\mathcal{A}$. For any query, $x$ made by $\mathcal{A}$ such that the first $k$ bits of $x$ match the first $k$ bits of one of $x_1, \ldots x_y$ answer as $F_n^{k+1}$ else answer as $F_n^{k}$. Now we can conclude that there exists a $t$ such that $F_n^{k,t}$ and $F_n^{k,t+1}$ are distinguishable with non-negligible probability.
    %DIF > Finally, we will show that using an adversary that can distinguish between $F_n^{k,t}$ and $F_n^{k,t+1}$ we need to construct an adversary $\mathcal{B}$ that refutes the DDH assumption. We leave construction of this adversary as an exercise.
\end{proof}


\newpage
\section*{\DIFadd{Exercises}}
\begin{exercise}
    %DIF >  \newcommand{\bit}{\{0,1\}}

    \DIFadd{Prove or disprove: If $f$ is a one-way function, then the following function $B:\bit^*\to\bit$ is a hardconcentrate predicate for $f$. The function $B(x)$ outputs the inner product modulo 2 of the first $\lfloor |x|/2\rfloor$ bits of $x$ and the last $\lfloor |x|/2\rfloor$ bits of $x$.
}\end{exercise}

\begin{exercise}
    \DIFadd{Let $\phi(n)$ denote the first $n$ digits of $\pi = 3.141592653589\ldots$ after the decimal in binary ($\pi$ in its binary notation looks like $11.00100100001111110110101010001000100001\ldots$).
}

    \DIFadd{Prove the following: if one-way functions exist, then there exists a one-way function $f$ such that the function $B:\{0,1\}^* \rightarrow \{0,1\}$ is not a hard concentrate bit of $f$. The function $B(x)$ outputs $\langle x, \phi(|x|)\rangle$, where
    }\[\DIFadd{\langle a, b\rangle := \sum_{i=1}^n a_i b_i \mod 2}\]
    \DIFadd{for the bit-representation of $a = {a_1a_2\cdots a_n}$ and $b= {b_1b_2\cdots b_n}$.
}\end{exercise}

\begin{exercise}
    \DIFadd{If $f: \{0,1\}^{n}\times \{0,1\}^n\rightarrow \{0,1\}^n$  is PRF, then in which of the following cases is $g: \{0,1\}^{n}\times \{0,1\}^n\rightarrow \{0,1\}^n$ also a PRF? }\begin{enumerate} \item \DIFadd{$g(K,x) = f(K,f(K,x))$ }\item \DIFadd{$g(K,x) = f(x,f(K,x))$ }\item \DIFadd{$g(K,x) = f(K,f(x,K))$
    }\end{enumerate}
\end{exercise}

\begin{exercise}[Puncturable PRFs.] \DIFadd{Puncturable PRFs are PRFs for which a key can be given out such that, it allows evaluation of the PRF on all inputs, except for one designated input.
}

    %DIF > \newcommand{\negl}{\mathsf{negl}}
    \newcommand{\A}{\mathcal{A}}
    \newcommand{\F}{F}
    \newcommand{\KeyF}{\mathsf{Key}_{\F}}
    \newcommand{\PunctureF}{\mathsf{Puncture}_{\F}}
    \newcommand{\EvalF}{\mathsf{Eval}_{\F}}


    \DIFadd{A puncturable pseudo-random function $\F$ is given by a triple of efficient algorithms ($\KeyF$,$\PunctureF$, and $\EvalF$), satisfying the following conditions:
    }\begin{itemize}
        \item[\DIFadd{-}] \textbf{\DIFadd{Functionality preserved under puncturing}}\DIFadd{: For every $x^*, x \in \{0,1\}^{n}$ such that $x^* \neq x$, we have that:
              }$$\DIFadd{\Pr[\EvalF(K,x) = \EvalF(K_{x^*},x) : K \gets \KeyF(1^n), K_{x^*} = \PunctureF(K,x^*)] = 1}$$
        \item[\DIFadd{-}] \textbf{\DIFadd{Pseudorandom at the punctured point}}\DIFadd{: For every $x^*\in \{0,1\}^n$ we have that for every polysize adversary $\A$ we have that:
              }$$\DIFadd{|\Pr[\A(K_{x^*}, \EvalF(K,x^*)) = 1] - \Pr[\A(K_{x^*}, \EvalF(K,U_n)) = 1]|= \negl(n)}$$
              \DIFadd{where $K \gets \KeyF(1^n)$ and $K_S = \PunctureF(K,x^*)$. $U_n$ denotes the uniform distribution over $n$ bits.
    }\end{itemize}

    \DIFadd{Prove that: If one-way functions exist, then there exists a puncturable PRF family that maps $n$ bits to $n$ bits. }\\
    \textbf{\DIFadd{Hint:}} \DIFadd{The GGM tree-based construction of PRFs from a length doubling pseudorandom generator (discussed in class) can be adapted to construct a puncturable PRF. Also note that $K$ and $K_{x^*}$ need not be the same length.
}\end{exercise}
%DIF > 
%DIF > \subsection{Application}
%DIF > Consider an interesting game: Alice and Bob are talking on the phone.
%DIF > Alice flips a coin, and Bob guesses whether it's head or tail.
%DIF > But the problem is how can Alice convince Bob that the coin is indeed head or tail?
%DIF > If we have pseudorandom functions, the problem could be easily solved.
%DIF > 
%DIF > Assume we have a PRF $F_n: \{0, 1\}^n \rightarrow \{0, 1\}^n$.
%DIF > Alice and Bob have a shared key $i \in \{0, 1\}^n$, then $f_i(\cdot)$ is shared information.
%DIF > Now Alice has a message $m \in \{0, 1\}^n$ and wants to let Bob guess it,
%DIF > the procedure consists of three steps.
%DIF > \begin{enumerate}[(a)]
%DIF >     \item Alice chooses a string $r \in \{0, 1\}^n$, and sends to Bob  $m' = f_i(r) \oplus m$ ;
%DIF >     \item Bob guesses $m$;
%DIF >     \item Alice sends $r$ to Bob.
%DIF > \end{enumerate}
%DIF > In step (a), since $F_n$ is PRF, all the information that Bob gets is a random $n$-bit string, so it will not influence his behavior in step (b).
%DIF > Then in step (c), Bob receives $r$ and will be convinced that the true value of $m$ is $f_i(r) \oplus m'$.
%DIF > 

\chapter{\DIFadd{Private-Key Cryptography}}
%DIF > \newcommand{\key}{\mathsf{k}}
%DIF >  \newcommand{\gen}{\mathsf{Gen}}
\section{\DIFadd{Private-Key Encryption}}
\DIFadd{The first primitive that we will study in private-key cryptography is that of private-key encryption.
When talking about private-key encryption, we will be working in a setting where two players, Alice and Bob, are attempting to communicate with each other.
}

\DIFadd{Alice and Bob want to communicate with each other.
For simplicity, let's assume that only Alice wants to send a message to Bob.
The crucial property that they want is that no eavesdropper attempting to listen to the conversation should be able to decipher the contents of the message being sent.
}\begin{comment}
\begin{center}
    \begin{tikzpicture}
        \draw;
    \end{tikzpicture}
\end{center}    
\end{comment}
%DIF >  Figure A goes here

\DIFadd{To achieve this, the two employ the following communication protocol:
}\begin{enumerate}
    \item \DIFadd{A priori, Alice and Bob generate a key $k$ and distribute it in such a way that only the two of them know what $k$ is.
    }\item \DIFadd{Using $k$, Alice can encrypt her message $m$, to turn it into a ciphertext $c$, which she sends over to Bob. 
    }\item \DIFadd{Upon receiving $c$, Bob can decrypt its contents and recover $m$ by using $k$.
}\end{enumerate}
\DIFadd{This meta-scheme implies a couple of requirements.
First of all, we want Bob to indeed be able to recover $m$ when decrypting $c$ with $k$.
It is no use having a communication scheme where the message received is not the one sent. We will call this requirement }\textit{\DIFadd{correctness}}\DIFadd{.
The second requirement, which we have already mentioned, is }\textit{\DIFadd{confidentiality}}\DIFadd{.
To reiterate, }\textit{\DIFadd{confidentiality}} \DIFadd{means that no eavesdropper that manages to get a hold of $c$ should be able to learn anything about $c$ that they do not already know (assuming they have no knowledge of the key $k$).
In addition to these two fundamental requirements, we might also impose that our private-key encryption scheme guarantees }\textit{\DIFadd{integrity}} \DIFadd{and }\textit{\DIFadd{authenticity}}\DIFadd{.
By }\textit{\DIFadd{integrity}}\DIFadd{, we mean that Bob should be able to detect that the message $c$ has been tampered with prior to him receiving it.
By }\textit{\DIFadd{authenticity}}\DIFadd{, we mean that Bob should be able to verify that the message he received was indeed sent by Alice, and not some adversary interfering with the conversation.
}

\DIFadd{Now that we have some intuitive understanding of what we are trying to achieve, let us attempt to ground it in mathematics.
}

\begin{definition}[Private-Key Encryption Scheme]
    \DIFadd{A private-key encryption scheme $\Pi$ is a tuple $\Pi = (\gen, \enc, \dec)$, where $\gen, \enc$, and $\dec$ are algorithms such that:
    }\begin{enumerate}
        \item \DIFadd{$\gen(1^n) \rightarrow k$
        }\item \DIFadd{$\enc(k, m) \rightarrow c$
        }\item \DIFadd{$\dec(k, c) \rightarrow m'$
    }\end{enumerate}

    \DIFadd{where $n$ is a security parameter and $k, c, m, m' \in \{0, 1\}^*$
}\end{definition}


%DIF > Alice might also want to be able to deal with attackers that can tamper with $c$.
%DIF > When Bob receives something, he wants to be able to verify that it indeed comes from Alice.

\begin{comment}
$$\Pi = (Gen, Enc, Dec)$$
$$Gen(1^n) \rightarrow k$$
$$Enc(k, m) \rightarrow c$$
$$Dec(k, c) \rightarrow m'$$
\end{comment}


%DIF >  Besides correctness, we want our cryptosystem to be \textit{confidential}.

\DIFadd{Now, we will formalize the requirements of our cryptosystem.
Our first requirement is correctness, which is defined below:
}

\begin{definition}[(Perfect) Correctness]
    \DIFadd{We say that a private-key encryption scheme $\Pi = (\gen, \enc, \dec)$ is }\emph{\DIFadd{(perfectly) correct}} \DIFadd{if 
    $\forall n, k \in \gen(1^n), m \in \{0,1\}^{*}$,
    }$$\DIFadd{\Pr[\dec(k,\enc(k,m)) = m] = 1}$$
\end{definition}
\DIFadd{That is, if $c = \enc(k, m)$, then Bob is guaranteed to recover $m$ by running $\dec(k, c)$. Note that for a fixed-length encryption scheme, we require that $m \in \bit^{l(n)}$.
}

\DIFadd{Next, we will formalize what we mean by }\textit{\DIFadd{confidentiality}}\DIFadd{.
We will often use the terms }\textit{\DIFadd{confidentiality}} \DIFadd{and }\textit{\DIFadd{security}} \DIFadd{interchangeably in the context of private-key encryption schemes.
Our first definition of confidentiality is called IND Security, stated below:
}

\begin{definition}[IND Security]
    \DIFadd{$\forall m_0, \forall m_1$ s.t. $|m_0| = |m_1|= l(n)$ and $\forall$ nu-PPT $\ma$ we have
    }$$\DIFadd{|\Pr[\ma(1^n, \enc(k, m_0)) = 1 \; | \; k \leftarrow \gen(1^n)] - |\Pr[\ma(1^n, \enc(k, m_1)) = 1 \; | \; k \leftarrow \gen(1^n)]| = neg(n)}$$ 
\end{definition}
\DIFadd{Note that this is not a particularly good definition of security, in the sense that the attacker is very limited in what they are allowed to do.
Specifically, all that $\ma$ can do is take a look at the encryption of $m_0$ and $m_1$ and must decide which one is the plaintext.
We need a more usable and realistic definition of security.
For this reason, we will allow the attacker to have oracle access to the encryption function, $\enc(k, \cdot)$.
In other words, $\ma$ will be able to craft their own ciphertexts, which it can then use to break the security of the encryption scheme.
We shall dub this new definition of security }\textit{\DIFadd{Chosen Plaintext Attack Security}}\DIFadd{, or }\textit{\DIFadd{CPA Security}} \DIFadd{for short.
}

%DIF > Informally, this means that the ciphertext $c$ should hide everything about $m$ that Eve doesn't already know.

\DIFadd{In defining }\textit{\DIFadd{CPA Security}}\DIFadd{, we will also introduce a new method for defining private-key encryption schemes: the game-style definition.
The rationale behind this change in style is that probabilistic definitions, while precise and rigorous, are rather cumbersome to work with, especially in the context of secure communication.
Therefore, we will adopt this new paradigm, which will make it easier to work with and reason about private-key encryption schemes.
}

\marginnote[-1.5in]{
\procedureblock[linenumbering]{$ \pcnotionstyle{Priv\pcmathhyphen{}}\indcpa_{\Pi}^{\adv}(\secpar)$}{
 b \getsr \bin \\
  \key  \getsr \gen ( \secparam ) \\
 ( \state ,m_0 ,m_1) \getsr \adv^{\enc ( \key ,\cdot )} ( \secparam) \\
 c \getsr \enc ( \key ,m_b ) \\
 b' \getsr \adv^{\enc ( \key ,\cdot )} ( \state , c ) \\
 \pcreturn b = b' \land |m_0| = |m_1| = l(n)
 }}

\begin{definition}[CPA Security]
    \DIFadd{A private-key encryption scheme $\Pi = (\gen,\enc,\dec)$ is CPA-secure if $\forall$ nu-PPT $\ma$
    }$$\DIFadd{\advantage{\indcpa}{\Pi,\adv} = \Big| \Pr[\pcnotionstyle{Priv\pcmathhyphen{}}\indcpa_\Pi^\adv(\secpar) =1] -\frac{1}{2}\Big|}$$
    \DIFadd{is a negligible function.
}\end{definition}
\DIFadd{Observe that in this new game-style definition, we have a concrete notion of the order in which each action is taken.
One important detail to note (and that is more evident in a game-style definition) is that in our }\textit{\DIFadd{CPA Security}} \DIFadd{definition,
the key $k$ is sampled }\textit{\DIFadd{before}} \DIFadd{$m_0$ and $m_1$ are fixed.
This is in contrast to }\textit{\DIFadd{IND Security}}\DIFadd{, in which the messages $m_0$ and $m_1$ are chosen before the key $k$ is sampled}\footnote{\DIFadd{This is an important detail because if $m_0$ and $m_1$ are chosen before $k$ is sampled, then giving oracle access to $\ma$ is not much help.}}\DIFadd{.
}

\DIFadd{To further illustrate this point, consider the following scheme, which is secure in IND but insecure in CPA:
}\begin{itemize}
    \item \DIFadd{$\gen(\secparam):$
    }\begin{enumerate}
        \item \DIFadd{$k \leftarrow \gen(\secparam)$
        }\item \DIFadd{$x \getsr \{0, 1\}^n$
        }\item \DIFadd{$k' = (k, x)$
    }\end{enumerate}
    \item \DIFadd{$\enc'(k', m)L:$
    }\begin{enumerate}
        \item \DIFadd{if $m = x$, then output $x$
        }\item \DIFadd{else, output $\enc(k,m)||x$
    }\end{enumerate}
\end{itemize}

%DIF > We formalize this property in our definition of \emph{Chosen Plaintext Attack Security}, or \textit{CPA Security} for short.
%DIF > In presenting this new definition, we will also introduce the notion of game-style definitions.
%DIF > The motivation behind this is that probabilistic definitions, such as the ones we have been working with thus far, are cumbersome and difficult to work with.
%DIF > Game-style definitions are easier to work with and give us better ideas of 

%DIF > Properties we want:
\DIFaddend %\begin{itemize}
%DIF < 	\item $d$-HE is an HE scheme that allows for $Eval$ on circuits of depth $d$ with the property that $|e|\leq poly(|m|,k)$.
%DIF < 	\item Encryption scheme has decryption circuit of some depth say $\alpha\cdot d$.
%DIF < 	\item circularly secure encryption	
%DIF >     \item $c$ should hide everything about $m$ that Eve doesn't already know
%\end{itemize}
%DIF < 	\item Construct 0 depth homomorphic encryption? DDH-Elgamal
%DIF < 	\item Given a circularly secure $d$-HE with decryption circuit of size $\alpha\cdot d$ construct an FHE.
%DIF < 	\item Open: Does FHE imply IBE? Can we do without circular security?	
%DIF < \end{itemize}
\DIFdelbegin %DIFDELCMD < \fi
%DIFDELCMD < \bibliography{cryptobib/abbrev0,cryptobib/crypto}
%DIFDELCMD < \bibliographystyle{plainnat}
%DIFDELCMD < \printbibliography
%DIFDELCMD <  %%%
\DIFdelend \DIFaddbegin 

%DIF > There are many ways to formally define this notion
%DIF > Formally,

%DIF >  To make this definition of security more robust, we allow $\ma$ to have oracle access\footnote{In other words, $\ma$ can create their own ciphertexts.} to $\enc(k, \cdot)$
%DIF >  This definition is not good enough because we are fixing $m_0$ and $m_1$. * ASK ABOUT THIS.

\begin{comment}
\begin{definition}[$\pcnotionstyle{Priv\pcmathhyphen{}}\indcpa$] A private-key encryption scheme $\Pi = (\gen,\enc,\dec)$ is $\pcnotionstyle{Priv\pcmathhyphen{}}\indcpa$-secure if 
$$ \advantage{\indcpa}{\Pi,\adv} = \Large\mid \Pr[\pcnotionstyle{Priv\pcmathhyphen{}}\indcpa_\Pi^\adv(\secpar) =1] -\frac12\Large\mid$$
is a negligible function. 
\end{definition}    
The main difference is when the key $k$ is sampled.
In the first definition, $m_0$ and $m_1$ are fixed before $k$ is sampled,
whereas in the second definition, $k$ is sampled before $m_0$ and $m_1$ are fixed.
\end{comment}

%DIF >  Transition from the probability-style definitions to game-style definitions.


\DIFadd{The final security notion we will define is CCA (chosen-ciphertext attack) security.
Here, the attacker is allowed oracle access to both the encryption and the decryption functions.
Let $L$ be the working list of queries that $\ma$ has made to $Dec(k, \cdot)$.
Then $\pcnotionstyle{Priv\pcmathhyphen{}}\indcca_{\Pi}^{\adv}(\secpar)$ is defined as:
}\marginnote[-1.5in]{
\procedureblock[linenumbering]{$ \pcnotionstyle{Priv\pcmathhyphen{}}\indcca_{\Pi}^{\adv}(\secpar)$}{
 b \getsr \bin \\
  \key  \getsr \gen ( \secparam ) \\
 ( \state ,m_0 ,m_1) \getsr \adv^{\enc ( \key ,\cdot ), \dec(k, \cdot)} ( \secparam) \\
 c \getsr \enc ( \key ,m_b ) \\
 b' \getsr \adv^{\enc ( \key ,\cdot ), \dec(k, \cdot)} ( \state , c ) \\
 \pcreturn b = b' \land |m_0| = |m_1| \land c \notin L
 }}

\begin{definition}[CCA Security]
    \DIFadd{A private-key encryption scheme $\Pi = (\gen,\enc,\dec)$ is CCA-secure if $\forall$ nu-PPT $\ma$
    }$$\DIFadd{\advantage{\indcca}{\Pi,\adv} = \Big| \Pr[\pcnotionstyle{Pri\pcmathhyphen{}}\indcca_\Pi^\adv(\secpar) =1] -\frac{1}{2}\Big|}$$
    \DIFadd{is a negligible function.
}\end{definition}

\DIFadd{$\Pi$ is a fixed-length encryption scheme for length $l(n)$ if $l(n)$ is polynomial in $n$ and $|m_0| = |m_1| = l(n)$.
}

\begin{theorem}
    \DIFadd{If F is a PRF then the scheme $\Pi = (\gen, \enc, \dec)$ given below is a secure encryption scheme for length $n$.
}

    \begin{itemize}
        \item \DIFadd{$\gen(\secparam)$:
        }\begin{enumerate}
            \item \DIFadd{output $k \getsr \{0, 1\}^n$
        }\end{enumerate}
        \item \DIFadd{$\enc(k, m)$:
        }\begin{enumerate}
            \item \DIFadd{$r \getsr \{0, 1\}^n$
            }\item \DIFadd{output $(r, F_k(r) \oplus m)$
        }\end{enumerate}
        \item \DIFadd{$\dec(k, c=(c_1, c_2))$:
        }\begin{enumerate}
            \item \DIFadd{output $c_2 \oplus F_k(c_1)$
        }\end{enumerate}
    \end{itemize}

\end{theorem}

\proof
\DIFadd{Assume there exists a nu-PPT $\ma$ that is able to break CPA security of $\Pi$.
Then we can construct a nu-PPT adversary $\mb$ that breaks the PRF $F$.
The strategy is outlined in the figure below:
}

\begin{center}
    \begin{tikzpicture}
        % Adversary B rectangle
        \draw (0,8) node[anchor=north west]{$\mb$};
        \draw (0, 0) rectangle (12, 8);
        \draw[thick, ->] (0,7)--(-1,7) node[anchor=south west] {$x$};
        \draw[thick, ->] (-1,6)--(0,6) node[anchor=south east] {$F(x)$};
        \draw (9, 0.5) rectangle (11, 7.5);
        % Adversary A rectangle
        \draw (9,7.5) node[anchor=north west]{$\ma$};
        \draw[thick, ->] (0,2)--(-1,2) node[anchor=south west] {$x^*$};
        \draw[thick, ->] (-1,1)--(0,1) node[anchor=south east] {$F(x^*)$};
        \draw[thick, ->] (0,0)--(-1,0) node[anchor=north west] {Output $b = b'$};
        \draw[thick, ->] (9,7)--(8,7) node[anchor=south west] {$m$};
        \draw[thick, ->] (8,6)--(9,6) node[anchor=south east] {$c$};
        \draw[thick, ->] (9,5)--(8,5) node[anchor=south west] {$m_0, m_1$};
        % \draw[thick, ->] (8,4)--(9,4) node[anchor=south east] {$c^*$};
        % \draw[thick, ->] (9,3)--(8,3) node[anchor=south west] {$m$};
        \draw[thick, ->] (8,2)--(9,2) node[anchor=south east] {$c^*$};
        \draw[thick, ->] (9,1)--(8,1) node[anchor=south west] {$b$};
        % Pseudocode
        \draw (3, 7) node[anchor=west] {1. $x \getsr \{0, 1\}^n$};
        \draw (3, 6) node[anchor=west] {2. $y = F(x)$};
        \draw (3, 5) node[anchor=west] {3. $c = (x, m \oplus y)$};
        \draw (3, 3) node[anchor=west] {4. $b \getsr \{0, 1\}$};
        \draw (3, 2) node[anchor=west] {5. $x^* \getsr \{0, 1\}^n$};
        \draw (3, 1) node[anchor=west] {6. $c^* = (x^*, m_b \oplus F(x^*))$};
        % Other arrows
        \draw[thick, dashed, red, ->] (2.75, 7)--(0.25,7);

        \draw[thick, dashed, red, ->] (0.25,6)--(2.75, 6);

        \draw[thick, dashed, blue, ->] (6.25, 5) .. controls (6.75, 5) and (7.4, 6) .. (7.75,6);

        \draw[thick, dashed, red, <-] (0.25, 2)--(2.75,2);

        \draw[thick, dashed, red, ->] (0.25, 1)--(2.75,1);

        \draw[thick, dashed, blue, ->] (5.25, 1.35) .. controls (6.75, 1.75) .. (7.75,2);

        \draw[thick, dashed, blue, <-] (0,0.1) .. controls (7, 0.2) .. (7.75, 1);

    \end{tikzpicture}
\end{center}
\DIFadd{After running this procedure, we guess ``Pseudorandom" if $b=b'$.
Else, we guess random.
}


\DIFadd{Now we argue that 
}$$\DIFadd{|\Pr[B^{F_n(\cdot)}(1^n) = 1] - \Pr[\mb^{F_n(\cdot)}(1^n) = 1]|}$$
\DIFadd{is non-negligible.
}

\begin{align*}
    \DIFadd{|\Pr[B^{F_n(\cdot)}(1^n) = 1] - \Pr[\mb^{F_n(\cdot)}(1^n) = 1]| }&\DIFadd{\ge \frac{1}{2} + \epsilon(n) - (\frac{1}{2} + \frac{q(n)}{2^n}) }\\
    &\DIFadd{= \epsilon(n) - \frac{q(n)}{2^n}
}\end{align*}
\qed

\begin{theorem}
    \DIFadd{No deterministic encryption scheme $\Pi$ can be CPA Secure.
}\end{theorem}

\proof
\DIFadd{The proof of this claim is simple.
If we have a deterministic encryption scheme, then when we get $c^*$, we can again try to encrypt a message and check if $c = c^*$
}\qed


\subsection{\DIFadd{Counter Mode Encryption}}
\DIFadd{One construction of a CCA-secure cipher is by the use of the counter mode.
}

\begin{itemize}
    \item \DIFadd{$\enc(k, (m_1,...,m_\ell)):$
    }\begin{algorithmic}[1]
        \item \DIFadd{$r \getsr \{0,1\}^n$
        }\item \DIFadd{Output $c = (r, m_1 \oplus F_k(r+1),
            m_2 \oplus F_k(r+2),
            ...,
            m_\ell \oplus F_k(r+\ell))$
    }\end{algorithmic}
\end{itemize}

\DIFadd{Consider the following picture:
}

\begin{center}
    \begin{tikzpicture}
        \draw[thick, ->] (0,0)--(12,0);
        \draw[thick, -] (1, 0.25)--(1, -0.25);
        \draw (1, -0.75) node[anchor=south] {$x_1$};
        \draw[thick, -] (2.5, 0.25)--(2.5, -0.25);
        \draw (2.5, -0.75) node[anchor=south] {$x_1 + q(n)$};
        \draw[thick, -] (5, 0.25)--(5, -0.25);
        \draw (5, -0.75) node[anchor=south] {$x_2$};
        \draw[thick, -] (6.5, 0.25)--(6.5, -0.25);
        \draw (6.5, -0.75) node[anchor=south] {$x_2 + q(n)$};
        \draw (9.5, -0.75) node[anchor=south] {...};
    \end{tikzpicture}
\end{center}

\DIFadd{Then the probability of breaking this cipher is
}$$\DIFadd{\frac{2q(n) - 1}{2^n} \cdot q(n)}$$

\DIFadd{In practice, we use block ciphers, which are stronger primitives.
}

\section{\DIFadd{Message Authentication Codes}}
\DIFadd{Now we address the question of how we can guarantee the }\textit{\DIFadd{integrity}} \DIFadd{of a message.
To achieve this, we will construct a new primitive, called a }\textit{\DIFadd{message authentication code}}\DIFadd{, or MAC for short. MACs generate a verifiable tag $t$ for a message $m$ that cannot be forged.
}

\DIFadd{When sending a message, Alice sends the pair $(m, t)$.
Once Bob receives the message, he runs $\Verify(k, m, t)$.
He accepts the message if $\Verify(k, m, t) = 1$, otherwise he rejects the message.
The formal definition is stated below:
}\begin{definition}[Private-Key Encryption Scheme]
    \DIFadd{A MAC scheme $\Pi$ is a tuple of algorithms $\Pi = (\gen, \mac, \Verify)$, with the following syntax:
    }\begin{enumerate}
        \item \DIFadd{$k \leftarrow \gen(1^n)$
        }\item \DIFadd{$t \leftarrow \mac(k,m)$
        }\item \DIFadd{$0/1 \leftarrow \Verify(k, m, t)$
    }\end{enumerate}
    \DIFadd{where $n$ is a security parameter and $k, m \in \{0, 1\}^{l(n)}$
}\end{definition}

\DIFadd{We impose the following }\textit{\DIFadd{correctness}} \DIFadd{requirement on our MACs:
}\begin{definition}[MAC Correctness]
    $$\DIFadd{\forall n, k \in \gen(1^n), m \in \{0, 1\}^*, \Pr[\Verify(k, m, \mac(k, m)) = 1] = 1}$$
\end{definition}

\DIFadd{We also want the message authentication codes to be }\textit{\DIFadd{unforgeable}}\DIFadd{.
That is, given a message $m$, a nu-PPT attacker $\ma$ should only be able to forge a tag $t$ for $m$ with negligible probability.
}\begin{definition}[EUF-CMA Security]
    \DIFadd{A MAC scheme $\Pi = (\gen,\mac,\Verify)$ is EUF-CMA-secure if $\forall$ nu-PPT $\ma$,
    }$$\DIFadd{\Big| \Pr\left[\mathsf{MAC}\pcmathhyphen{}\mathsf{forge}_{\cA, \Pi}(\secpar) =1\right]\Big| = \negl}$$
\end{definition}

\begin{definition}[$\mathsf{MAC}\pcmathhyphen{}\mathsf{forge}_{\cA, \Pi}(\secpar)$]
\DIFadd{$ $
   }\begin{enumerate}
        \item \textbf{\DIFadd{Setup:}} \DIFadd{The challenger samples $k$ uniformly from the key space. $\cA$ is given $1^n$.
        }\item \textbf{\DIFadd{Query:}} \DIFadd{The adversary submits a message $m^{(i)}$; then the challenger computes a tag $t^{(i)} \gets \mac(k, m^{(i)})$ and sends it to the adversary. The adversary may submit any polynomial number of message queries.
        }

        \DIFadd{Let $\mathcal{Q} = \{(m^{(1)}, t^{(1)}), \dots, (m^{(q)}, t^{(q)})\}$ be the set of messages $m^{(i)}$ submitted in the query phase along with the tags $t^{(i)}$ computed by $\mac$.
        }\item \textbf{\DIFadd{Forgery:}} \DIFadd{The adversary outputs a message-tag pair $(m^*, t^*)$. The output of the game is $1$ if $(m^*,t^*) \notin \mathcal{Q}$ and $\Verify(k, m^*, t^*) = 1$. The output is $0$ otherwise.
    }\end{enumerate}
\end{definition}


%DIF > \marginnote[-1.5in]{
%DIF > \procedureblock[linenumbering]{$ \pcnotionstyle{OLDPri\pcmathhyphen{}}\indcpa_{\Pi}^{\adv}(\secpar)$}{
%DIF >  b \sample \bin \\
%DIF >   \key  \sample \gen ( \secparam ) \\
%DIF >  ( \state ,m_0 ,m_1) \sample \adv^{\enc ( \key ,\cdot )} ( \secparam) \\
%DIF >  c \sample \enc ( \key ,m_b ) \\
%DIF >  b' \sample \adv^{\enc ( \key ,\cdot )} ( \state , c ) \\
%DIF >  \pcreturn b = b' }
%DIF >  }

 
\newcommand{\nonnegl}{\mathsf{nonnegl}}


\section{\DIFadd{Fixed-length MACs}}

\DIFadd{Previously, we defined what a MAC is, and specified correctness and security definitions for MACs. In this section, we'll define a fixed-length MAC for length $\ell(n)$.
}

\begin{theorem}
    \DIFadd{If $F : \{0, 1\}^n \to \{0, 1\}^n$ is a secure PRF, then the MAC scheme $\Pi = (\mathsf{Gen}, \mathsf{Mac}, \mathsf{Verify})$ constructed below has EUF-CMA security.
}

    \begin{itemize}
        \item \DIFadd{$\gen(1^n):$
        }\begin{algorithmic}
            \item \DIFadd{Output $k \getsr \{0, 1\}^n$
        }\end{algorithmic}
        \item \DIFadd{$\mac(k,m):$
        }\begin{algorithmic}
            \item \DIFadd{Output $t = F_k(m)$
        }\end{algorithmic}
        \item \DIFadd{$\Verify(k, m, t)$
        }\begin{algorithmic}
            \item \DIFadd{If $t = F_k(m)$, then return $1$. 
            }\item \DIFadd{Otherwise return $0$.
        }\end{algorithmic}
    \end{itemize}
    \DIFadd{That is, we just compute the PRF on our message as the MAC.
}\end{theorem}

\begin{proof}
    \DIFadd{To prove security, suppose for contradiction that there exists an adversary $A$ that breaks the security for $\Pi$. We'd like to construct an adversary $B$ that breaks the security of the PRF.
}

    \DIFadd{Here, the adversary $A$ expects queries for tags, given messages as input. $B$ can simply forward these requests on to $F$, and return the response back to $A$. Further, $A$ outputs a pair $(m^*, t^*)$, which $B$ can send $m^*$ to $F$, and output whether $t = t^*$.
}

    \begin{center}
        \begin{tikzpicture}
            \draw (3, 0) rectangle (8, 5.5);
            \draw (5, 0.5) rectangle (7.5, 5);
            \node at (3.25, 5.25) {$B$};
            \node at (5.25, 4.75) {$A$};

            \draw (5.5, 4) edge[->] node[right, pos=0] {$m$} (2.5, 4)
                (2.5, 3.5) edge[->] node[right, pos=1] {$t$} (5.5, 3.5);
            \node[left] at (2.5, 3.75) {$F_k$};
            \node at (5.5, 3.1) {$\vdots$};
            \node at (4.5, 3.1) {$\vdots$};
            \draw (5.5, 2.5) edge[->] node[right, pos=0] {$(m^*, t^*)$} (4.5, 2.5);

            \draw (3.5, 2.5) edge[->] node[right, pos=0] {$m^*$} (2.5, 2.5);
            \node[left] at (2.5, 2.25) {$F_k$};
            \draw (2.5, 2) edge[->] node[right, pos=1] {$t$} (3.5, 2);
            \draw (3.5, 1) edge[->] node[right, pos=0] {$t \overset{?}{=} t^*$} (2.5, 1);
        \end{tikzpicture}
    \end{center}

    \DIFadd{Analyzing the probability for $B$, we have
    }\[
        \DIFadd{\abs{\Pr(B^{F_k(\cdot)}(1^n) = 1) - \Pr(B^{R_n(\cdot)}(1^n) = 1)}
        = \abs{\varepsilon_A(n) - \frac{1}{2^n}}
        = \nonnegl(n)
    .}\]
    \DIFadd{Here, the first term is because the correctness follows immediately from the correctness of $A$, and the second term is due to the fact that the output of $R_n$ is random.
}\end{proof}

\section{\DIFadd{Variable-length MACs}}

\DIFadd{Now, let us look at messages with lengths that are a multiple of $n$. In particular, we have a few blocks $m_1, \ldots, m_{\ell}$, each of size $n$. There are a few ways to do this, but we'll look at a method similar to the counter mode we looked at last time.
}

\begin{center}
    \begin{tikzpicture}
        \node (m1) at (0, 2) {$m_1$};
        \node (m2) at (1, 2) {$m_2$};
        \node (m3) at (2, 2) {$m_3$};
        \node (mdots) at (3, 2) {$\cdots$};
        \node (ml) at (4, 2) {$m_{\ell}$};

        \node[draw] (fk1) at (0, 0) {$F_k$};
        \node[draw] (fk2) at (1, 0) {$F_k$};
        \node[draw] (fk3) at (2, 0) {$F_k$};
        \node at (3, 0) {$\ldots$};
        \node[draw] (fkl) at (4, 0) {$F_k$};

        \node[outer sep=0pt, inner sep=0pt, draw, circle] (fk1+m2) at (1, 1) {$+$};
        \node[outer sep=0pt, inner sep=0pt, draw, circle] (fk2+m3) at (2, 1) {$+$};
        \node[outer sep=0pt, inner sep=1pt] (xor-dots) at (3, 1) {$\ldots$};
        \node[outer sep=0pt, inner sep=0pt, draw, circle] (dots+ml) at (4, 1) {$+$};

        \draw (m1) edge[->] (fk1)
            (m2) edge[->] (fk1+m2)
            (m3) edge[->] (fk2+m3)
            (ml) edge[->] (dots+ml);

        \draw[->] (fk1) -- ++(0.5, 0) |- (fk1+m2);
        \draw[->] (fk2) -- ++(0.5, 0) |- (fk2+m3);
        \draw[->] (fk3) -- ++(0.5, 0) |- (xor-dots);

        \draw[->] (xor-dots) -- (dots+ml);
        \draw (fk1+m2) edge[->] (fk2)
            (fk2+m3) edge[->] (fk3)
            (dots+ml) edge[->] (fkl);
        \draw (fkl) edge[->] ++(1, 0);
    \end{tikzpicture}
\end{center}

\DIFadd{This construction avoids having to store a tag equal in length to the message, but this is not secure, due to length extension attacks. In particular, suppose we query for the tag $t$ associated with $0^n$. We can then query another tag $t'$ for $0^n \oplus t$. Observe here that $t'$ is also the tag for $0^{2n}$.
}

\DIFadd{A solution is to use different keys for each PRF, but this isn't too efficient, since we're still calling the PRF once per block of length $n$. We'll instead improve this to use only one block cipher call---we do some preprocessing and only call $F_k$ once on the output of the preprocessing.
}

\DIFadd{In particular, we'll claim that applying a universal hash function to the input and then applying the block cipher is a secure MAC.
}

\begin{definition}[Universal Hash Function]
    \DIFadd{A function $h : \mathcal{F} \times \mathcal{F}^* \to \mathcal{F}$ (where $\mathcal{F}$ is a field of size $2^m$) is a universal hash function if for all $m, m' \in \mathcal{F}^{\le \ell}$ (i.e. $m$ and $m'$ have length at most $\ell$),
    }\[
        \DIFadd{\Pr_s(h(s, m) = h(s, m')) \le \frac{\ell}{\abs{F}}
    .}\]
    \DIFadd{That is, the probability of collision is small.
}\end{definition}

\DIFadd{Crucially here, we fix $m$ and $m'$, and we sample $s$. (If we fix an $s$, we can almost surely find an $m$ and $m'$ that collide.)
}

\DIFadd{Today, we'll look at the following function:
}\[
    \DIFadd{h(s, m_0, \ldots, m_{\ell - 1}) = m_0 + m_1 s + m_2 s^2 + \cdots + m_{\ell - 1} s^{\ell - 1} + s^{\ell}
.}\]

\begin{claim}
    \DIFadd{The function defined by
    }\[
        \DIFadd{h(s, m_0, \ldots, m_{\ell - 1}) = m_0 + m_1 s + m_2 s^2 + \cdots + m_{\ell - 1} s^{\ell - 1} + s^{\ell}
    }\]
    \DIFadd{is a universal hash function.
}\end{claim}

\begin{proof}
    \DIFadd{We'd like to argue that for a fixed $m$ and $m'$, and a random $s$, the probability that there is a collision is at most $\frac{\ell}{\abs{\mathcal{F}}}$.
}

    \DIFadd{We'll look at
    }\[
        \DIFadd{h(x, m_0, \ldots, m_t) - h(x, m_0', \ldots, m_t') = (m_0 - m_0') + \cdots + (m_{t - 1} - m_{t-1}') x^{\ell - 1}
    .}\]
    \DIFadd{If there is a collision, this difference is 0. The probability that this polynomial of degree at most $\ell$ has a zero at $x$ is at most $\frac{\ell}{\abs{\mathcal{F}}}$, since it has at most $\ell$ zeroes. This means that $h$ is indeed a universal hash function.
}\end{proof}

\begin{claim}
    \DIFadd{The MAC given by $F_k(h(s, m_1, \ldots, m_{\ell}))$, for the universal hash function $h$ given prior, is secure. (This is a slight variation on the Carter--Wegman MAC.)
}\end{claim}

\begin{proof}
    \DIFadd{Suppose for contradiction that there exists a nu-PPT $A$ that breaks the security of this scheme.
}

    \DIFadd{Here, for appropriately generated $k$ and $s$, $A$ makes queries $m \mapsto F_k(h_s(m))$, and outputs $(m^*, t^*)$.
}

    \DIFadd{We'd like to create an adversary $B$ that either breaks the security of the PRF, or breaks the security of the universal hash function.
}

    \DIFadd{$B$ will start by sampling $s \in \mathcal{F}$. When given the query for $m_1$, it computes $h_s(m_1)$ and queries for $F_k(h_s(m_1))$, which it sends back to $A$. If $F_k$ was actually pseudorandom, then $A$ is given a pseudorandom input, and if $F_k$ was random $R_n$, then $A$ is given a random input.
}

    \DIFadd{$A$ must still be able to generate pairs $(m^*, t^*)$ even when given a random input, due to the security of the PRF.
}

    \begin{center}
        \begin{tikzpicture}
            \draw (2, 0) rectangle (8, 5.5);
            \draw (5, 0.5) rectangle (7.5, 5);
            \node at (2.25, 5.25) {$B$};
            \node at (5.25, 4.75) {$A$};

            \node at (3.5, 4.5) {sample $s \in \mathcal{F}$};

            \node (hsm) at (3.5, 4) {$h_s(m)$};
            \draw (5.5, 4) edge[->] node[right, pos=0] {$m$} (hsm)
                (hsm) edge[->] (1.5, 4)
                (1.5, 3.5) edge[->] node[right, pos=1] {$t$} (5.5, 3.5);
            \node[left] at (1.5, 3.75) {$F_k$};
            \node at (5.5, 3.1) {$\vdots$};
            \node at (4.5, 3.1) {$\vdots$};

            \node (hash-m-star) at (3.5, 2.5) {$h_s(m^*)$};
            \draw (5.5, 2.5) edge[->] node[right, pos=0] {$(m^*, t^*)$} (hash-m-star)
                (hash-m-star) edge[->] (1.5, 2.5);
            \node[left] at (1.5, 2.25) {$F_k$};
            \draw (1.5, 2) edge[->] node[right, pos=1] {$t$} (3.5, 2);
            \draw (3.5, 1) edge[->] node[right, pos=0] {$t \overset{?}{=} t^*$} (1.5, 1);
        \end{tikzpicture}
    \end{center}

    \DIFadd{Let $E$ be the event that there exists an $m, m' \in L \cup \{m^*\}$, such that $h_s(m) = h(m')$. If $E$ does not happen, then the hash function never collides. This means that the attacker only sees random values depending on distinct inputs, so this reduces to the case from earlier (when the MAC is just $F_k$).
}

    \DIFadd{As such, we'd like to show that collisions in $h_s(\cdot)$ occur with negligible probability.
}

    \DIFadd{To show this, suppose for contradiction that collisions actually do occur with non-negligible probability. We then want to construct an adversary $B$ utilizing $A$ that just outputs $m$ and $m'$ such that when $s$ is sampled, $h_s(m) = h_s(m')$ with high probability.
}

    \DIFadd{$B$ will pick a random $i, j \in \{1, \ldots, q+1\}$ (here suppose $i < j$), where $q$ is the number of MAC queries. We then run $A$ until the $j$th query. Taking the $i$th and $j$th query, we then output $m_i$ and $m_j$ as our pair of messages. We still need to entertain the queries made by $A$, so we can just return random values for tags (giving the same value if it requests it for the same message).
}

    \begin{center}
        \begin{tikzpicture}
            \draw (2, 0) rectangle (8, 6);
            \draw (5, 0.5) rectangle (7.5, 5.5);
            \node at (2.25, 5.75) {$B$};
            \node at (5.25, 5.25) {$A$};

            \node[align=center] at (3.5, 5) {\small $i, j \xleftarrow{\$} \{1, \ldots, q+1\}$};

            \draw (5.5, 4) edge[->] node[right, pos=0] {$m_1$} (4.5, 4)
                (4.5, 3.5) edge[->] node[left, pos=0] {sample $t_1$} node[right, pos=1] {$t_1$} (5.5, 3.5);
            \node at (5.5, 3.1) {$\vdots$};
            \node at (4.5, 3.1) {$\vdots$};

            \draw (5.5, 2.5) edge[->] node[right, pos=0] {$m_i$} (4.5, 2.5)
                (4.5, 2) edge[->] node[left, pos=0] {sample $t_i$} node[right, pos=1] {$t_i$} (5.5, 2);
            \node at (5.5, 1.6) {$\vdots$};
            \node at (4.5, 1.6) {$\vdots$};

            \draw (5.5, 1) edge[->] node[right, pos=0] {$m_j$} (4.5, 1);

            \draw (3, 0.5) edge[->] node[right, pos=0] {$(m_i, m_j)$} (1.5, 0.5);
        \end{tikzpicture}
    \end{center}

    \DIFadd{By assumption, we know that $E$ occurs with non-negligible probability. That is, among the queries made by $A$, there is a non-negligible probability that $h_s(m_i) = h_s(m_j)$. Since here the implementation of $B$ just picks out a pair of random queries from those made by $A$, the pair $(m_i, m_j)$ output by $B$ also has a collision with non-negligible probability. (In particular, with probability $\Pr(E) / q^2$.
}

    \DIFadd{This breaks the definition of a universal hash function, which is a contradiction.
}\end{proof}

\DIFadd{So far, we know how to generate tags of fixed length, and of lengths that are a multiple of $n$. If we have a message that is not a multiple of $n$, we could potentially just pad the input with 0's, but this causes an issue, as $m$ and $m \concat 0$ have the same tag.
}

\DIFadd{Instead, one solution is to put the size of the message in the first block, and we can still put the padding at the end. This way, if the messages differ by length, the first block will be different, and if the messages do not differ by length, then we're essentially just ignoring the padding. This gives us a MAC for arbitrary-length messages.
}

\section{\DIFadd{Authenticated Encryption Schemes}}

\DIFadd{We've talked about confidentiality and integrity separately, but generally we want both properties---when Alice sends a message to Bob, we'd like for any eavesdropper to be unable to recover the message, }\emph{\DIFadd{and}} \DIFadd{we'd like Bob to be able to verify that the message actually came from Alice.
}

\DIFadd{A scheme that achieves both of these conditions is called an }\emph{\DIFadd{authenticated encryption scheme}}\DIFadd{.
}

\begin{definition}[Authenticated Encryption Scheme]
    \DIFadd{A scheme $\Pi$ is an }\emph{\DIFadd{authenticated encryption scheme}} \DIFadd{if it is CPA-secure, and it has ciphertext integrity (CI).
}\end{definition}

\begin{definition}[Ciphertext Integrity (CI)]
    \DIFadd{Consider the following game for the scheme $\Pi = (\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$.
}

    \begin{algorithmic}[1]
        \Function{CI${}_{\Pi}^A$}{$n$}
            \State \DIFadd{$k \gets \mathsf{Gen}(1^n)$
            }\State \DIFadd{$c^* \gets A^{\mathsf{Enc}(k, \cdot)}(1^n)$
            }\State \DIFadd{$L \gets$ the list of queries made by $A$
            }\State \Return \DIFadd{$(\mathsf{Dec}(k, c^*) \ne \bot) \land (c^* \notin L)$
        }\EndFunction
    \end{algorithmic}

    \DIFadd{A scheme has ciphertext integrity if for all nu-PPT $A$, $\Pr(\mathrm{CI}_{\Pi}^A)$ is negligible.
}\end{definition}

\DIFadd{Observe that an authenticated encryption scheme is also CCA-secure, since the CI property says that the adversary can never generate a valid ciphertext. This means that whenever an adversary requests the decryption of a ciphertext, we can always return $\bot$ (unless they previously requested a ciphertext for a message, and wants to decode that ciphertext). This means that the decryption oracle is essentially useless, and this reduces to the CPA case.
}

\DIFadd{Next, we'll construct an authenticated encryption scheme, called ``Encrypt-then-MAC'', utilizing a CPA-secure encryption scheme and an EUF-CMA MAC scheme.
}

\begin{claim}
    \DIFadd{Let $\Pi_e = (\mathsf{Gen}_e, \mathsf{Enc}_e, \mathsf{Dec}_e)$ be a CPA-secure encryption scheme, and let $\Pi_m = (\mathsf{Gen}_m, \mathsf{Mac}_m, \mathsf{Verify}_m)$ be an EUF-CMA-secure MAC scheme.
}

    \DIFadd{The following scheme $\Pi = (\mathsf{Gen}, \mathsf{Enc}, \mathsf{Dec})$ is an authenticated encryption scheme.
}

    \begin{algorithmic}[1]
        \Function{Gen}{$1^n$}
            \State \DIFadd{$k_e \gets \mathsf{Gen}_e(1^n)$
            }\State \DIFadd{$k_m \gets \mathsf{Gen}_m(1^n)$
            }\State \Return \DIFadd{$(k_e, k_m)$
        }\EndFunction
        \Statex
        \Function{Enc}{$(k_e, k_m), m$}
            \State \DIFadd{$c \gets \mathsf{Enc}_e(k_e, m)$
            }\State \DIFadd{$t \gets \mathsf{Mac}_m(k_m, c)$
            }\State \Return \DIFadd{$(c, t)$
        }\EndFunction
        \Statex
        \Function{Dec}{$(k_e, k_m), (c, t), m$}
            \If {\DIFadd{$\mathsf{Verify}_m(k_m, c, t)$}}
                \State \Return \DIFadd{$\mathsf{Dec}_e(k_e, c)$
            }\Else
                \State \Return \DIFadd{$\bot$
            }\EndIf 
        \EndFunction
    \end{algorithmic}
\end{claim}

\begin{proof}
    \DIFadd{Suppose for contradiction that we have an adversary $A$ that breaks the CPA security of $\Pi$. The CPA game allows for queries of the ciphertext for messages $m$, produces a pair $m_0, m_1$, and then gets $c^* = \mathsf{Enc}(k, m_B)$, and $A$ eventually outputs $b'$ to identify which message was encrypted.
}

    \DIFadd{We'd like to construct another adversary $B$, which breaks the CPA-security of $\Pi_e$. The only difference here is the MACs, so $B$ can sample a $k_m \gets \mathsf{Gen}_m(1^n)$, and perform all of the MACs itself.
}

    \DIFadd{In particular, when $A$ asks for the ciphertext of $M$, we pass it to the oracle for $\Pi_e$, and attach $t \gets \mathsf{Mac}_m(k_m, c)$. If $A$ is able to distinguish between ciphertexts of $M_0$ and $M_1$, then we can use the same bit to distinguish between ciphertexts for $\Pi_e$.
    }\begin{center}
        \begin{tikzpicture}
            \draw (1.5, -1) rectangle (8, 6);
            \draw (5, -0.5) rectangle (7.5, 5.5);
            \node at (1.75, 5.75) {$B$};
            \node at (5.25, 5.25) {$A$};

            \node at (3.25, 5) {$k_m \gets \textsc{Gen}_m(1^n)$};

            \node (enc) at (3.25, 3.5) {$C = \textsc{Enc}_e(k_e, m)$};
            \node (mac) at (3.25, 3) {$(C, \textsc{Mac}_m(k_m, C))$};

            \draw (5.5, 4) edge[->] node[right, pos=0] {$m$} (1, 4)
                (1, 3.5) edge[->] (enc)
                (mac) edge[->] node[right, pos=1] {$c$} (5.5, 3);
            \node[left] at (1, 3.75) {$\textsc{Enc}_e(k_e, \cdot)$};
            \node at (5.5, 2.6) {$\vdots$};
            \node at (4.5, 2.6) {$\vdots$};

            \draw (5.5, 2) edge[->] node[right, pos=0] {$m_1, m_2$} node[left, pos=1] {$m_1, m_2$} (1, 2);
            \node (enc-mb) at (3.25, 1.5) {$C^*$};
            \node (mac-mb) at (3.25, 1) {$(C^*, \textsc{Mac}_m(k_m, C^*))$};
            \draw (1, 1.5) edge[->] node[left, pos=0] {$\textsc{Enc}_e(k_e, m_b)$} (enc-mb);
            \draw (mac-mb) edge[->] node[right, pos=1] {$c^*$} (5.5, 1);

            \node at (5.5, 0.5) {$\vdots$};
            \node at (4.5, 0.5) {$\vdots$};

            \draw (5.5, 0) edge[->] node[right, pos=0] {$b'$} (1, 0);
        \end{tikzpicture}
    \end{center}

    \DIFadd{To prove ciphertext integrity, suppose we have an adversary $A$ that breaks the ciphertext integrity of $\Pi$. Here, $A$ asks for ciphertext queries, and eventually returns a new ciphertext that is valid.
}

    \DIFadd{We'd like to construct an adversary $B$ that is able to generate a new message and a tag, given oracle access to the MAC scheme. The construction will follow similarly to the prior proof on CPA security.
}

    \DIFadd{Here, our adversary $B$ can sample $k_e \gets \mathsf{Gen}_e(1^n)$. When $A$ asks for the encryption of $M$, $B$ can send $m = \mathsf{Enc}_e(k_e, M)$ to the MAC oracle, and it returns $c = (m, t)$ to $A$.
}

    \DIFadd{When $A$ returns $C^* = (c^*, t^*)$, $B$ can also just return the same, since the tag $t^*$ is being computed on $c^*$.
}

    \begin{center}
        \begin{tikzpicture}
            \draw (1.5, 1) rectangle (8, 6);
            \draw (5, 1.5) rectangle (7.5, 5.5);
            \node at (1.75, 5.75) {$B$};
            \node at (5.25, 5.25) {$A$};

            \node at (3.25, 5) {$k_e \gets \textsc{Gen}_e(1^n)$};

            \node (enc) at (3.25, 4) {$C = \textsc{Enc}_e(k_e, m)$};
            \node (mac) at (3.25, 3.5) {$T = \textsc{Mac}_m(k_m, C)$};
            \node (enc-mac) at (3.25, 3) {$(C, T)$};

            \draw (5.5, 4) edge[->] node[right, pos=0] {$m$} (enc)
                (enc) edge[->] (1, 4)
                (1, 3.5) edge[->] (mac)
                (enc-mac) edge[->] node[right, pos=1] {$c$} (5.5, 3);
            \node[left] at (1, 3.75) {$\textsc{Mac}_m(k_m, \cdot)$};
            \node at (5.5, 2.6) {$\vdots$};
            \node at (4.5, 2.6) {$\vdots$};

            \node (gen-ciphertext) at (3.25, 2) {$(C^*, T^*)$};
            \draw (5.5, 2) edge[->] node[right, pos=0] {$c^*$} (gen-ciphertext)
                (gen-ciphertext) edge[->] (1, 2);
        \end{tikzpicture}
    \end{center}
\end{proof}

\DIFadd{As an example, AES-GCM is the most popular authenticated encryption scheme that is used, and also has the ability to authenticate additional data. (AES-GCM basically just appends the associated data to the ciphertext, so that the encryption is only on the message, but the MAC is on both the ciphertext and the associated data.) This scheme uses a counter-mode encryption scheme, and the MAC that we saw, but makes this more efficient.
}


%DIF >  !TEX root = collection.tex

\chapter{\DIFadd{Digital Signatures}}

\DIFadd{In this chapter, we will introduce the notion of a digital signature. At an intuitive level, a digital signature scheme helps providing authenticity of messages and ensuring non-repudiation. We will first define this primitive and then construct what is called as one-time secure digital signature scheme. An one-time digital signature satisfies a weaker security property when compared to digital signatures. We then introduce the concept of collision-resistant hash functions and then use this along with a one-time secure digital signature to give a construction of digital signature scheme.
}

\section{\DIFadd{Definition}}

\DIFadd{A digital signature scheme is a tuple of three algorithms $(\Gen,\Sign,\Verify)$ with the following syntax:
}\begin{enumerate}
\item \DIFadd{$\Gen(1^n)\to (vk,sk)$: On input the message length (in unary) $1^n$, $\Gen$ outputs a secret signing key $sk$ and a public verification key $vk$.
}\item \DIFadd{$\Sign(sk, m) \to \sigma$: On input a secret key $sk$ and a message $m$ of length $n$, the $\Sign$ algorithm outputs a signature $\sigma$.
}\item \DIFadd{$\Verify(vk, m, \sigma) \to \{0,1\}$: On input the verification key $vk$, a message $m$ and a signature $\sigma$, the $\Verify$ algorithm outputs either $0$ or $1$.
}\end{enumerate}

\DIFadd{We require that the digital signature to satisfy the following correctness and security properties.}\\
\medskip
\noindent\textbf{\DIFadd{Correctness.}} \DIFadd{For the correctness of the scheme, we have that
$\forall m \in \bin^n$,
}\[\DIFadd{\Pr \left[ (vk,sk) \gets \Gen(1^n), \sigma \leftarrow \Sign(sk,m) : \Verify(vk, m, \sigma) = 1 \right] = 1.}\]

\medskip
\noindent\textbf{\DIFadd{Security.}} \DIFadd{Consider the following game between an adversary and a challenger
.
}

\begin{enumerate}
    \item \DIFadd{The challenger first samples $(vk,sk) \gets \Gen(1^n)$. The challenger gives $vk$ to the adversary.
    }\item \textbf{\DIFadd{Signing Oracle.}} \DIFadd{The adversary is now given access to a signing oracle. When the adversary gives a query $m$ to the oracle, it gets back $\sigma \gets \Sign(sk,m)$.
    }\item \textbf{\DIFadd{Forgery.}} \DIFadd{The adversary outputs a message, signature pair $(m^*,\sigma^*)$ where $m^*$ is different from the queries that adversary has made to the signing oracle.
    }\item \DIFadd{The adversary wins the game if $\Verify(vk,m^*,\sigma^*) = 1$.
}\end{enumerate}
\DIFadd{We say that the digital signature scheme is secure if the probability that the adversary wins the game is $\negl(n)$.
}

\section{\DIFadd{One-time Digital Signature}}
\label{lampart}
\DIFadd{An one-time digital signature has the same syntax and correctness requirement as that of a digital signature scheme except that in the security game the adversary is allowed to call the signing oracle only once (hence the name one-time). We will now give a construction of one-time signature scheme from the assumption that one-way functions exists.
}

\DIFadd{Let $f: \bin^n \rightarrow \bin^n$ be a one-way function.
}\begin{itemize}
\item \DIFadd{$\Gen(1^n)$: On input the message length (in unary) $1^n$, $\Gen$ does the following:
}\begin{enumerate}
    \item \DIFadd{Chooses $x_{i,b} \gets \bin^n$ for each $i \in [n]$ and $b \in \bin$.
    }\item \DIFadd{Output %
\mbox{%DIFAUXCMD
$vk = \left[ \begin{array}{ccc}
f(x_{1,0}) & \ldots & f(x_{n,0}) \\
f(x_{1,1}) & \ldots & f(x_{n,1}) \\
\end{array} \right]$
}%DIFAUXCMD
and %
\mbox{%DIFAUXCMD
$sk = \left[ \begin{array}{ccc}
x_{1,0} & \ldots & x_{n,0} \\
x_{1,1} & \ldots & x_{n,1} \\
\end{array} \right]$
}%DIFAUXCMD
}\end{enumerate}
\item \DIFadd{$\Sign(sk, m)$: On input a secret key $sk$ and a message $m \in \bin^n$, the $\Sign$ algorithm outputs a signature $\sigma = x_{1,m_1}\|x_{2,m_2}\| \ldots \| x_{n,m_n}$.
}\item \DIFadd{$\Verify(vk, m, \sigma)$: On input the verification key $vk$, a message $m$ and a signature $\sigma$, the $\Verify$ algorithm does the following:
}\begin{enumerate}
    \item \DIFadd{Parse $\sigma = x_{1,m_1}\|x_{2,m_2}\| \ldots \| x_{n,m_n}$.
    }\item \DIFadd{Compute $vk'_{i,m_i} = f(x_{i,m_i})$ for each $i \in [n]$.
    }\item \DIFadd{Check if for each $i \in [n]$, $vk'_{i,m_i} = vk_{i,m_i}$. If all the checks pass, output 1. Else, output 0.
}\end{enumerate}
\end{itemize}

\DIFadd{Before we prove any security property, we first observe that this scheme is completely broken if we allow the adversary to ask for two signatures. This is because the adversary can query for the signatures on $0^n$ and $1^n$ respectively and the adversary gets the entire secret key. The adversary can then use this secret key to sign on any message and break the security. 
}

\DIFadd{We will now argue the one-time security of this construction. Let $\adv$ be an adversary who breaks the security of our one-time digital signature scheme with non-negligible probability $\mu(n)$. We will now construct an adversary $\advb$ that breaks the one-wayness of $f$. $\advb$ receives a one-way function challenge $y$ and does the following:
}\begin{enumerate}
    \item \DIFadd{$\advb$ chooses $i^*$ uniformly at random from $[n]$ and $b^*$ uniformly at random from $\bin$.
    }\item \DIFadd{It sets $vk_{i^*,b^*} = y$
    }\item \DIFadd{For all $i \in [n]$ and $b \in \bin$ such that $(i,b) \neq (i^*,b^*)$, $\advb$ samples $x_{i,b} \gets \bin^n$. It computes $vk_{i,b} = f(x_{i,b})$.
    }\item \DIFadd{It sets %
\mbox{%DIFAUXCMD
$vk = \left[ \begin{array}{ccc}
vk_{1,0} & \ldots& vk_{n,0} \\
vk_{1,1} & \ldots& vk_{n,1} \\
\end{array} \right]$
}%DIFAUXCMD
and sends $vk$ to $\adv$.
}\item \DIFadd{$\adv$ now asks for a signing query on a message $m$. If $m_{i^*} = b^*$ then $\advb$ aborts and outputs a special symbol $\abort_1$. Otherwise, it uses it knowledge of $x_{i,b}$ for $(i,b) \neq (i^*,b^*)$ to output a signature on $m$.
}\item \DIFadd{$\adv$ outputs a valid forgery $(m^*,\sigma^*)$. If $m^*_{i^*} = m_{i^*}$ then $\advb$ aborts and outputs a special symbol $\abort_2$. If it does not abort, then it parses $\sigma^*$ as ${1,m_1}\|x_{2,m_2}\| \ldots \| x_{n,m_n}$ and outputs $x_{i^*,b^*}$ as the inverse of $y$.
}\end{enumerate}
\DIFadd{We first note that conditioned on $\advb$ not outputting $\abort_1$ or $\abort_2$, the probability that $\advb$ outputs a valid preimage of $y$ is $\mu(n)$. Now, probability $\advb$ does not output $\abort_1$ or $\abort_2$ is $1/2n$ (this is because $\abort_1$ is not output with probability $1/2$ and conditioned on not outputting $\abort_1$, $\abort_2$ is not output with probability $1/n$). Thus, $\advb$ outputs a valid preimage with probability $\mu(n)/2n$. This completes the proof of security.
}

\DIFadd{We now try to extend this one-time signature scheme to digital signatures. For this purpose, we will rely on a primitive called as collision-resistant hash functions.
}

\DIFadd{Before we turn to collision-resistant hash functions however, we show how to use the arbitrary-length WOOF we constructed to boost this one-time, fixed-length digital signature scheme into a one-time, arbitrary-length digital signature scheme. 
}

\subsection{\DIFadd{Removing Length-Restriction from One-Time Digital Signatures}} 

\DIFadd{Let $(\Gen_\ell, \Sign_\ell, \Verify_\ell)$ be a length-restricted one-time digital signature for messages of length $\ell(n)$. 
Let $h_s: \{0,1\}^* \to \{0,1\}^n$ be a WOOF. 
First we will review an }\emph{\DIFadd{insecure}} \DIFadd{first attempt at a construction for $\ell(n) = n$: 
}\begin{itemize}
    \item \DIFadd{$\Gen^{\text{BAD}}(1^n)$: Run $(pk_\ell, sk_\ell) \leftarrow \Gen_\ell(1^n)$, $s \leftarrow I(1^n)$. Output $((pk_\ell,s),sk_\ell)$.
}

    \item \DIFadd{$\Sign^{\text{BAD}}(sk=sk_\ell, m)$: Output $\Sign_\ell(sk_\ell, h_s(m))$. 
}

    \item \DIFadd{$\Verify^{\text{BAD}}(pk=(pk_\ell,s), m, \sigma)$: Output $\Verify_\ell(pk_\ell, h_s(m), \sigma)$. 
}\end{itemize}
\DIFadd{Notice that this construction does not work because the seed for the WOOF is revealed before the message is chosen, in which case WOOF security does not apply. 
}

\DIFadd{To avoid this, we can use the following construction for $\ell(n) = k(n) + n$ where $k(n)$ is the length of the seed produced by $I(1^n)$: 
}\begin{itemize}
    \item \DIFadd{$\Gen(1^n)$: Run $(pk_\ell, sk_\ell) \leftarrow \Gen_\ell(1^n)$. Output $(pk_\ell,sk_\ell)$.
}

    \item \DIFadd{$\Sign(sk=sk_\ell, m)$: Run $s \leftarrow I(1^n)$ and $\sigma_\ell \leftarrow \Sign_\ell(sk_\ell, s || h_s(m))$. Output $(\sigma_\ell, s)$. 
}

    \item \DIFadd{$\Verify(pk=pk_\ell, m, \sigma = (\sigma_\ell, s))$: Output $\Verify_\ell(pk_\ell, s || h_s(m), \sigma_\ell)$. 
}\end{itemize}
\DIFadd{Note that now the seed is chosen after the message. 
We will give a proof sketch of the security for this construction. 
Assume for contradiction that we have a nu-PPT adversary $\adv$ which succeeds with non-negligible probability at the digital signature security game for $(\Gen, \Sign, \Verify)$. 
We will now construct a nu-PPT adversary $\advb$ who succeeds with non-negligible probability at the digital signature security game for $(\Gen_\ell, \Sign_\ell, \Verify_\ell)$, a contradiction. 
$\advb$ receives $pk_\ell$ from its challenger and passes this along to $\adv$. 
When $\adv$ queries the signing oracle with message $m$, $\advb$ runs $s \leftarrow I(1^n)$, computes $m_{\ell} = s || h_{s}(m)$, queries its signing oracle with message $m_{\ell}$ to receive $\sigma_\ell$ and returns $\sigma = (s, \sigma_{\ell})$ to $\adv$. 
Finally, when $\adv$ returns $m^*, \sigma^* = (s^*, \sigma_{\ell}^*)$, $\advb$ outputs $m^*_{\ell} = s^* || h_{s^*}(m^*), \sigma_{\ell}^*$. 
}

\DIFadd{Since we have replicated the expected input distribution for $\adv$, it will succeed with non-negligible probability. 
Notice that $\advb$ will succeed when $\adv$ does as long as $m^*_{\ell} \not = m_{\ell}$. 
In analyzing the success probability of $\advb$ we have two cases to consider based on whether $s^* = s$. 
Notice that $\adv$ must have non-negligible success either when $s^* = s$ or when $s^* \not = s$ or both. 
If $\Pr[s^* \not = s \land \adv \text{ succeeds}]$ is non-negligible, then $\advb$ also succeeds with non-negligible probability since $m^*_{\ell} = s^* || h_{s^*}(m^*) \not = s || h_{s}(m) = m_{\ell}$ in this case. 
Now assume that $\Pr[s^* = s \land \adv \text{ succeeds}]$ is non-negligible. When $\adv$ succeeds in this case, it must have found $m^* \not = m$, and so $h_{s^*}(m^*) = h_{s}(m)$ with only negligible probability because otherwise WOOF security is broken. 
Thus with non-negligible probability $m^*_{\ell} \not = m_{\ell}$ and $\advb$ succeeds as well. 
Therefore either way $\advb$ succeeds in the digital signature game against $(\Gen_\ell, \Sign_\ell, \Verify_\ell)$ with non-negligible probability. 
}

\section{\DIFadd{Multiple-Message Digital Signatures}} 

\DIFadd{Now we will show how to covert this one-time, no-length restriction digital signature scheme $(\Gen, \Sign, \Verify)$ into a ef-ema no-length restriction digital signature scheme by utilizing a pseudorandom function $PRF$. 
For each $\alpha \in \{\epsilon\} \cup \{0,1\}^{\leq n}$, let $pk_\alpha, sk_\alpha = \Gen(1^n; PRF_s(\alpha 10 \ldots 0))$ such that $|\alpha 10 \ldots 0| = n+1$ (i.e. $\Gen$ is run with randomness determined by the PRF on an input specified by $\alpha$). 
We will use these to make a tree of keys so that the keys used for each message will be distinct with high probability, so WOOF security will continue to apply each time the scheme is used. 
Note that whenever $\Sign$ is called, we require the WOOF to be run with a deterministic seed $s_{\alpha}^W = PRF_{s'}(\alpha 10 \ldots 0)$. 
This way paths through the tree will deterministically map to the corresponding signatures. 
The construction is as follows: 
}\begin{itemize}
    \item \DIFadd{$\mathsf{GEN}(1^n)$: Output $(pk_\epsilon, s \leftarrow \{0,1\}^n)$, namely the root public key and the seed for the PRF so the rest of the keys can be generated. 
}

    \item \DIFadd{$\mathsf{SIGN}(sk, m)$: 
    }\begin{enumerate}
        \item \DIFadd{Draw a random path through the key tree $r \leftarrow \{0,1\}^n$. 
}

        \item \DIFadd{Now use the secret key at each level to sign its children's public keys and continue to do this along the random path until a leaf is hit, i.e. iteratively sign the random path and its co-path. 
        Namely, for each $i = 0, 1, \ldots, n-1$, let $\alpha_i = r_1 r_2 \cdots r_i$, $m_i = pk_{\alpha_i || 0} || pk_{\alpha_i || 1}$, and $\sigma_i = \Sign(sk_{\alpha_i}, m_i)$. 
}

        \item \DIFadd{Let $\sigma_n = \Sign(sk_r, m)$. 
}

        \item \DIFadd{Output $\Sigma = (r, m_0, \sigma_0, \ldots, m_{n-1}, \sigma_{n-1}, \sigma_n)$. 
    }\end{enumerate} 

    \item \DIFadd{$\mathsf{VERIFY}(pk, m, \Sigma = (r, \sigma_0, \ldots, \sigma_{n-1}, \sigma_n))$: Use $r$ and the $m_i$ to determine $pk_{\alpha_i}$ and for each $i \in [n]$ run $\Verify(pk_{\alpha_i}, m_i, \sigma_i)$, accepting if all of those do. 
}\end{itemize}
\DIFadd{The idea is that because the root $pk_{\epsilon}$ is trusted and the corresponding secret keys of one level are used to validate the $pk$ of the level below, trust is maintained down the path and the ultimate $pk_r$ can be trusted to be used to check the signature on $m$ itself. 
}

\DIFadd{We will now give a proof sketch for the security of this construction. 
Assume for contradiction that we have a nu-PPT adversary $\adv$ which succeeds with non-negligible probability at the digital signature security game for $(\mathsf{GEN}, \mathsf{SIGN}, \mathsf{VERIFY})$. 
Let $\adv$'s interaction with this security game be called Hybrid $H_0$. 
First we will consider the hybrid $H_1$ where the PRF is replaced by a truly random function. 
$\adv$'s success probability in $H_1$ is still some non-negligible $\epsilon(n)$ due to PRF security. 
Now we will consider the hybrid $H_2$ where if the randomness returned by any two of the signing oracle queries is equal, i.e. $r_j = r_{j'}$ for some distinct $j, j' \in [q]$, then $\adv$ aborts. 
Notice that the probability of this happening is only $q^2/2^n$, a negligible amount, so $\adv$'s success probability $\epsilon(n) - q^2/2^n$ remains non-negligible. 
Thus going forward we can assume that the randomness $r_j$ used by the oracle to sign each query $m_j$ is distinct. 
}

\DIFadd{Now notice that either $\adv$ outputs a message-signature pair $(M^*, \Sigma^*)$ which uses $r^* = r_j$ for some $j \in [q]$ or $r^* \not = r_j$ for all $j \in [q]$. 
We will give some intuition for what happens in each of these cases. 
In the first case, since signatures in this scheme are deterministic, to succeed $\adv$'s signatures must be the same as $\Sigma_j$'s along the path $r^* = r_j$ until doing a forgery at the leaf, breaking the $(\Gen, \Sign, \Verify)$ scheme for $M^*$ which is distinct from all of the $m_j$ queries. 
In the second case, $\adv$ goes along a path $r^* \not = r_j$, so at the first node which diverges from all $r_j$ it must forge a signature that verifies with an honest public key from the level above, breaking the $(\Gen, \Sign, \Verify)$ scheme for the corresponding $\alpha_i^*$ which is distinct from all of the other $\alpha_i^j$ that were used to answer queries. 
}

\DIFadd{This can be formalized by constructing a nu-PPT adversary $\advb$ for the one-time digital signature security game of $(\Gen, \Sign, \Verify)$ who takes the $pk$ it's been given and guesses which query $\adv$ forges for, using its $pk$ and one-time oracle to provide a signature for that query and otherwise answering honestly using self-generated keys. 
This degrades $\advb$'s probability of success by $\epsilon(n)/q$ which is still non-negligible. 
}

\DIFadd{Next, after introducing collision resistant hash functions, we will see a different, though closely related, alternate construction for multiple-message digital signatures. 
}

\section{\DIFadd{Collision Resistant Hash Functions}}

\DIFadd{As the name suggests, collision resistant hash function family is a set of hash functions $H$ such that for a function $h$ chosen randomly from the family, it is computationally hard to find two different inputs $x,x'$ such that $h(x) = h(x')$. We now give a formal definition.
}

\subsection{\DIFadd{Definition of a family of CRHF}}

\DIFadd{A set of function ensembles
}\[ \DIFadd{\{H_n = \{h_i : D_n \to R_n \}_{i \in I_n} \}_n}\]
\DIFadd{where $|D_n| < |R_n|$ is a family of collision resistant hash function ensemble if there exists efficient algorithms $(\Sampler,\Eval)$ with the following syntax:
}\begin{enumerate}
\item \DIFadd{$\Sampler(1^n) \to i:$ On input $1^n$, $\Sampler$ outputs an index $i \in I_n$.
}\item \DIFadd{$\Eval(i,x) = h_i(x):$ On input $i$ and $x \in D_n$, $\Eval$ algorithm outputs $h_i(x)$. 
}\item \DIFadd{$\forall$ PPT $\adv$ we have
}\[\DIFadd{\Pr[i \gets \Sampler(1^n), (x,x') \gets \adv(1^n,i) : h_i(x) = h_i(x') \wedge x \neq x'] \leq \negl(n)}\]
\end{enumerate}


\subsection{\DIFadd{Collison Resistant Hash functions from Discrete Log}}
\DIFadd{We will now give a construction of collision resistant hash functions from the discrete log assumption. We first recall the discrete log assumption:
}\begin{definition}[Discrete-Log Assumption]
\DIFadd{We say that the discrete-log assumption holds for the group ensemble $\mathcal{G} =\{ \mathbb{G}_n\}_{n \in \mathbb{N}}$, if for every non-uniform PPT algorithm $\mathcal{A}$ we have that
}\[\DIFadd{\mu_\mathcal{A}(n) := \Pr_{x \leftarrow |G_n|}[\mathcal{A}(g,g^x) = x]}\]
\DIFadd{is a negligible function.
}\end{definition}

\DIFadd{We now give a construction of collision resistant hash functions.  
}

\begin{itemize}
\item \DIFadd{$\Sampler(1^n):$ On input $1^n$, the sampler does the following:
}\begin{enumerate}
    \item \DIFadd{It chooses $x \gets |\mathbb{G}_n|$.
    }\item \DIFadd{It computes $h = g^x$.
    }\item \DIFadd{It outputs $(g,h)$.
}

\end{enumerate}
\item \DIFadd{$\Eval((g,h),(r,s)):$ On input $(g,h)$ and two elements $(r,s) \in |\mathbb{G}_n|$, $\Eval$ outputs $g^rh^s$.
}\end{itemize}

\DIFadd{We now argue that this construction is collision resistant. Assume for the sake of contradiction that an adversary gives a collision $(r_1,s_1) \neq (r_2,s_2)$. We will now use this to compute the discrete logarithm of $h$. We first observe that:
}\begin{eqnarray*}
\DIFadd{r_1+xs_1 }&\DIFadd{=}& \DIFadd{r_2 + xs_2}\\
\DIFadd{(r_1 - r_2) }&\DIFadd{=}& \DIFadd{x(s_2 - s_1)
}\end{eqnarray*}
\DIFadd{We infer that $s_2 \neq s_1$. Otherwise, we get that $r_1 = r_2$ and hence, $(r_1,s_1) = (r_2,s_2)$. Thus, we can compute $x = \frac{r_1-r_2}{s_1 - s_2}$ and hence the discrete logarithm of $h$ is computable.
}

\section{\DIFadd{CRHF-Based Multiple-Message Digital Signatures}}

\DIFadd{We now explain how to combine collision-resistant hash functions and one-time signatures to get a signature scheme for multiple messages. We first construct an intermediate primitive wherein we will still have the same security property as that of one-time signature but we would be able to sign messages longer than the length of the public-key.}\footnote{\DIFadd{Note that in the one-time signature scheme that we constructed earlier, the length of message that can be signed is same as the length of the public-key.}}


\subsection{\DIFadd{One-time Signature Scheme for Long Messages}}
\DIFadd{We first observe that the CRHF family $H$ that we constructed earlier compresses $2n$ bits to $n$ bits (also called as 2-1 CRHF). We will now give an extension that compresses an arbitrary long string to $n$ bits using a 2-1 CRHF.
}\paragraph{\DIFadd{Merkle-Damgard CRHF.}} \DIFadd{The sampler for this CRHF is same as that of 2-1 CRHF. Let $h$ be the sampled hash function. To hash a string $x$, we do the following. Let $x$ be a string of length $m$ where $m$ is an arbitrary polynomial in $n$. We will assume that $m = kn$ (for some $k$) or otherwise, we can pad $x$ to this length. We will partition  the string $x$ into $k$ blocks of length $n$ each. For simplicity, we will assume that $k$ is a perfect power of $2$ or we will again pad $x$ appropriately. We will view these $k$-blocks as the leaves of a complete binary tree of depth $\ell = \log_2 k$. Each intermediate node is associated with a bit string $y$ of length at most $\ell$ and the root is associated with the empty string. We will assign a $\tag \in \bin^n$ to each node in the tree. The $i$-th leaf is assigned $\tag_i$ equal to the $i$-block of the string $x$. Each intermediate node $y$ is assigned a $\tag_y = h(\tag_{y\|0}\| \tag_{y \| 1})$. The output of the hash function is set to be the $\tag$ value of the root. Notice that if there is a collision for this CRHF then there are exists one intermediate node $y$ such that for two different values $\tag_{y\|0},\tag_{y\|1}$ and $\tag'_{y\|0},\tag'_{y\|1}$ we have, $h(\tag_{y\|0},\tag_{y\|1}) = \tag'_{y\|0},\tag'_{y\|1}$. This implies that there is a collision for $h$. 
}

\paragraph{\DIFadd{Construction.}} \DIFadd{We will now use the Merkle-Damgard CRHF and the one-time signature scheme that we constructed earlier to get a one-time signature scheme for signing longer messages. The main idea is simple: we will sample a $(sk,vk)$ for signing $n$-bit messages and to sign a longer message, we will first hash it using the Merkle-Damgard hash function to $n$-bits and then sign on the hash value. The security of the construction follows directly from the security of the one-time signature scheme since the CRHF is collision-resistant. 
}

\subsection{\DIFadd{Signature Scheme for Multiple Messages}}
\DIFadd{We will now describe the construction of signature scheme for multiple messages. Let $(\Gen',\Sign',\Verify')$ be a one-time signature scheme for signing longer messages. 
}\begin{enumerate}
    \item \DIFadd{$\Gen(1^n):$ Run $\Gen'(1^n)$ using to obtain $sk,vk$. Sample a PRF key $K$. The signing key is $(sk,K)$ and the verification key is $vk$.
    }\item \DIFadd{$\Sign((sk,K),m):$ To sign a message $m$, do the following:
    }\begin{enumerate}
        \item \DIFadd{Parse $m$ as $m_1m_2\ldots m_{\ell}$ where each $m_i \in \bin$.
        }\item \DIFadd{Set $sk_0 = sk$ and $m_0 = \epsilon$ (where $\epsilon$ is the empty string).
        }\item \DIFadd{For each $i \in [\ell]$ do:
        }\begin{enumerate}
            \item \DIFadd{Evaluate $\PRF(m_1\|\ldots\|m_{i-1}\|0)$ and $\PRF(m_1\|\ldots\|m_{i-1}\|1)$ to obtain $r_0$ and $r_1$ respectively. Run $\Gen'(1^n)$ using $r_0$ and $r_1$ as the randomness to obtain $(sk_{i,0},vk_{i,1})$ and $(sk_{i,1},vk_{i,1})$.
            }\item \DIFadd{Set $\sigma_i = \Sign(sk_{i-1,m_{i-1}},vk_{i,0}\|vk_{i,1})$
            }\item \DIFadd{If $i = \ell$, then set $\sigma_{\ell+1} = \Sign(sk_{i,m_i},m)$.
            }

        \end{enumerate}
        \item \DIFadd{Output $\sigma = (\sigma_1,\ldots,\sigma_{\ell+1})$ along with all the verification keys as the signature.
    }\end{enumerate}
    \item \DIFadd{$\Verify(vk,\sigma,m)$: Check if all the signatures in $\sigma$ are valid.
}\end{enumerate}

\DIFadd{To prove security, we will first use the security of the PRF to replace the outputs with random strings. We will then use the security of the one-time signature scheme to argue that the adversary cannot mount an existential forgery.
}

\section{\DIFadd{Trapdoor Permutations and RSA}} 

\begin{definition}[Trapdoor Permutation] 
\DIFadd{A function family $\{f_s: D_s \to D_s\}_{s \in \{0,1\}^*}$ is a }\emph{\DIFadd{one-way trapdoor permutation}} \DIFadd{if there exists PPT $I, D, F, F^{-1}$ such that 
}\begin{itemize}
    \item \DIFadd{$(s, \tau) \leftarrow I(1^n)$ produces the seed and trapdoor, 
    }

    \item \DIFadd{$D(s)$ outputs a uniformly random element of $D_s$, 
}

    \item \DIFadd{$\forall s \in I(1^n), x \in D_s$, $F(s, x) = f_s(x)$, 
}

    \item \DIFadd{$\forall (s, \tau) \in I(1^n), y \in D_s$, $F^{-1}(\tau, y) = f_s^{-1}(x)$, and 
}

    \item \DIFadd{$f_s$ is one-way. 
}\end{itemize}
\end{definition} 

\DIFadd{The RSA trapdoor permutation construction is as follows: 
}\begin{itemize} 

    \item \DIFadd{$I_{RSA}(1^n) \rightarrow (s = (N, e), \tau = (N, d)$ for $N = PQ$ for $2^{n-1} \leq P < Q \leq 2^n$ such that $d = e^{-1} \mod \phi(n)$ for $e < N$ which is coprime to $\phi(n) = (P-1)(Q-1)$. 
    Let $D_s = \{1, \ldots, N\}$. 
}

    \item \DIFadd{$F_{RSA}(s, x) = x^e \mod N$. 
}

    \item \DIFadd{$F_{RSA}^{-1}(\tau, x) = y^d \mod N$. 
}\end{itemize}
\DIFadd{Unfortunately, under the assumption that factoring is hard, we still don't have a security proof for the RSA trapdoor permutation in the plain model. 
However, we will see a proof in what's called the ``random oracle model'' next. 
}


\section*{\DIFadd{Exercises}}
\begin{exercise}
\textbf{\DIFadd{Digital signature schemes can be made deterministic.}} \DIFadd{Given a digital signature scheme $(\mathsf{Gen}, \mathsf{Sign}, \mathsf{Verify})$ for which $\mathsf{Sign}$ is probabilistic, provide a construction of a digital signature scheme $(\mathsf{Gen}', \mathsf{Sign}', \mathsf{Verify}')$ where $\mathsf{Sign}'$ is deterministic.
}\end{exercise}




\bibliography{cryptobib/abbrev0,cryptobib/crypto, cryptobib/smoser, cryptobib/ref}
 \DIFaddend\end{document}
